<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="Software Engineering - https://Tryanel.github.io/software-engineering/">
    <meta name="author" content="SantonLee - https://Tryanel.github.io/">
    
    <meta name="msvalidate.01" content="B46311949B856F2A7015F366FB3CE878" />
    <title>Software Engineering</title>
    <link rel="icon" type="image/png" href="/favicon.ico">
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-webfont/1.7.0/style.min.css" />
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" />
    
    <link rel="stylesheet" href="https://Tryanel.github.io/style.min.6bbccf0916939df698171c34d30f896276712c30bd56be0d7fd8023e1b00c3d9.css">
    
    <script type="text/javascript" src="/main.js" defer></script>
    
</head>
<body class="active-animate ">
        <div class="cool-before" style=""></div>
        <div id="header" class=""><div class="container-header">
    
    
    <div class="right">
        
        <h1 class="title">Software Engineering</h1>
    
        
            
            <div id="toc">📜</div>
        
    </div>
</div>
</div>
        <div id="content">










<div class="container-main container-page ">

    <div class="desc">
        
        <span>
            
            <svg t="1656736000388" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7409" width="12" height="12"><path d="M524.885333 338.986667L200.362667 663.466667c-17.28 15.274667-27.989333 36.693333-29.696 56.234666v133.76l130.730666 0.085334c22.784-1.621333 43.989333-12.245333 61.013334-31.701334l322.688-322.645333-160.213334-160.213333z m60.373334-60.330667l160.170666 160.213333 102.144-102.144a19.712 19.712 0 0 0 0-27.861333L715.093333 176.426667a19.456 19.456 0 0 0-27.605333 0L585.258667 278.613333zM701.312 85.333333c27.946667 0 54.741333 11.136 74.282667 30.848l132.309333 132.309334a105.045333 105.045333 0 0 1 0 148.565333L424.874667 879.957333c-29.824 34.346667-72.106667 55.466667-120.448 58.794667H85.333333v-42.666667l0.128-179.84c3.626667-44.970667 24.576-86.826667 56.448-114.944l485.12-485.034666A104.789333 104.789333 0 0 1 701.269333 85.333333z" p-id="7410" fill="#adb5bd"></path></svg>
            2023-12-13&nbsp;&nbsp;&nbsp;
            <svg t="1656737270708" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23838" width="11" height="11"><path d="M824.264 95.36c0-23.859 25.043-44.16 48.902-44.16s49.714 20.301 49.714 44.16v190.08c0 23.859-19.054 52.868-42.913 52.868h-190.08c-23.859 0-46.696-25.96-46.696-49.819s22.55-46.249 46.409-46.249h82.025C702.344 175.534 610.22 155.853 512 155.853c-206.775 0-360.398 149.372-360.398 356.147 0 206.775 153.623 358.23 360.398 358.23 206.775 0 357.467-151.455 357.467-358.23 0-23.859 23.634-50.706 53.413-50.706 29.78 0 49.92 26.847 49.92 50.706 0 254.493-206.307 460.8-460.8 460.8-254.493 0-460.8-206.307-460.8-460.8C51.2 257.507 257.507 51.2 512 51.2c122.4 0 226.684 33.296 312.264 117.369 0.358 0.351 0.358-24.052 0-73.209z" p-id="23839" fill="#adb5bd"></path></svg>
            2023-12-31&nbsp;&nbsp;&nbsp;
        </span>
        <span>
            
            <svg t="1656737548689" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="33866" width="12" height="12"><path d="M832.038608 64.662657H192.030028C121.255125 64.662657 63.940169 121.98845 63.940169 192.694717v446.793671C63.940169 710.205493 121.255125 767.643272 192.030028 767.643272h133.353183a63.940169 63.940169 0 0 1 55.219742 31.576328l76.099638 129.83828c12.358154 21.093031 33.790754 31.626903 55.216129 31.626903s42.832688-10.544709 55.198067-31.619678l76.222461-129.870792a63.940169 63.940169 0 0 1 55.212517-31.551041h133.54103c70.576219 0 127.732228-57.289669 127.732227-127.800865V192.391272C959.825022 121.85479 902.643727 64.662657 832.038608 64.662657zM895.884854 639.842407A63.85347 63.85347 0 0 1 832.092795 703.703103h-133.54103a127.753903 127.753903 0 0 0-110.349172 63.09847l-76.222461 129.856342a0.274545 0.274545 0 0 1 0-0.050574h-0.032512s-0.021675 0.061411-0.032512 0.061412l-76.1466-129.85273A127.804477 127.804477 0 0 0 325.383211 703.703103H192.030028A64.207489 64.207489 0 0 1 127.880338 639.488388V192.694717A64.102729 64.102729 0 0 1 192.030028 128.602826h640.00858A63.799284 63.799284 0 0 1 895.884854 192.391272v447.451135z" fill="#adb5bd" p-id="33867"></path><path d="M608.154093 288.092004A31.970084 31.970084 0 0 0 576.184009 320.062089v160.078006l-134.650049-179.278119A31.970084 31.970084 0 0 0 384.002258 320.062089v255.760676a31.970084 31.970084 0 0 0 63.940169 0v-159.958796l134.650048 179.274507a31.970084 31.970084 0 0 0 57.531703-19.200113V320.062089a31.970084 31.970084 0 0 0-31.970085-31.970085z" fill="#adb5bd" p-id="33868"></path></svg>
            29402 字</span>&nbsp;
        <span>
            
            <svg t="1656737462334" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="32892" width="12" height="12"><path d="M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667z m0 810.666666c-204.8 0-373.333333-168.533333-373.333333-373.333333S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z" p-id="32893" fill="#adb5bd"></path><path d="M695.466667 567.466667l-151.466667-70.4V277.333333c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v238.933334c0 12.8 6.4 23.466667 19.2 29.866666l170.666667 81.066667c4.266667 2.133333 8.533333 2.133333 12.8 2.133333 12.8 0 23.466667-6.4 29.866666-19.2 6.4-14.933333 0-34.133333-17.066666-42.666666z" p-id="32894" fill="#adb5bd"></path></svg>
            59 分钟</span>
            <div class="container-ctgtag">
	<div class="taxonomy">
		<div class="tag">
			
			
			<a href="/tags/cs">CS</a>
			
		</div>
	</div>
</div>
        
    </div>
    
    <div class="toc">
        <div class="container-page-operation">
	<div class="page-operation">
		<div><a href="/"><img src="/imgs/icons/home-2.svg" alt=""></a></div>
		<div><a href="/nav"><img src="/imgs/icons/iov-navigate-1.svg" alt=""></a></div>
		<div><a href="/tags"><img src="/imgs/icons/treetags.svg" alt=""></a></div>
		<div id="light-dark"><a><img src="/imgs/icons/moon2.svg" alt=""></a></div>
		<div><a href="#"><img src="/imgs/icons/up2.svg" alt=""></a></div>
	</div>
</div>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#第一章-软件工程学概述">第一章 软件工程学概述</a>
      <ul>
        <li><a href="#11-软件危机">1.1 软件危机</a></li>
        <li><a href="#12-软件工程">1.2 软件工程</a></li>
        <li><a href="#13-软件生命周期组成">1.3 软件生命周期组成</a></li>
        <li><a href="#14-软件过程概念">1.4 软件过程概念</a></li>
      </ul>
    </li>
    <li><a href="#第二章-可行性分析">第二章 可行性分析</a>
      <ul>
        <li><a href="#21-可行性研究的任务">2.1 可行性研究的任务</a></li>
        <li><a href="#22-可行性研究过程">2.2 可行性研究过程</a></li>
        <li><a href="#23-系统流程图">2.3 系统流程图</a></li>
        <li><a href="#24-数据流图概念">2.4 数据流图概念</a></li>
        <li><a href="#25-数据字典">2.5 数据字典</a></li>
        <li><a href="#26-成本--效益分析">2.6 成本 / 效益分析</a></li>
      </ul>
    </li>
    <li><a href="#第三章-需求分析">第三章 需求分析</a>
      <ul>
        <li><a href="#31-需求分析的任务">3.1 需求分析的任务</a></li>
        <li><a href="#32-与用户沟通获取需求的方法">3.2 与用户沟通获取需求的方法</a></li>
        <li><a href="#33-分析建模与规格说明">3.3 分析建模与规格说明</a></li>
        <li><a href="#34-实体---联系图e-r-图">3.4 实体 - 联系图（E-R 图）</a></li>
        <li><a href="#35-数据规范化">3.5 数据规范化</a></li>
        <li><a href="#36-状态转换图">3.6 状态转换图</a></li>
        <li><a href="#37-其他图形工具">3.7 其他图形工具</a></li>
        <li><a href="#38-验证软件需求">3.8 验证软件需求</a></li>
      </ul>
    </li>
    <li><a href="#第五章-总体设计">第五章 总体设计</a>
      <ul>
        <li><a href="#51-设计过程">5.1 设计过程</a></li>
        <li><a href="#52-设计原理">5.2 设计原理</a></li>
        <li><a href="#53-启发规则">5.3 启发规则</a></li>
        <li><a href="#54-描绘软件结构的图形工具">5.4 描绘软件结构的图形工具</a></li>
        <li><a href="#55-面向数据流的设计方法">5.5 面向数据流的设计方法</a></li>
      </ul>
    </li>
    <li><a href="#第六章-详细设计">第六章 详细设计</a>
      <ul>
        <li><a href="#61-结构程序设计">6.1 结构程序设计</a></li>
        <li><a href="#62-人机界面设计">6.2 人机界面设计</a></li>
        <li><a href="#63-过程设计的工具">6.3 过程设计的工具</a></li>
        <li><a href="#64-面向数据结构的设计方法">6.4 面向数据结构的设计方法</a></li>
        <li><a href="#65-程序复杂程度的定量度量">6.5 程序复杂程度的定量度量</a></li>
      </ul>
    </li>
    <li><a href="#第七章-实现">第七章 实现</a>
      <ul>
        <li><a href="#71-编码">7.1 编码</a></li>
        <li><a href="#72-软件测试基础">7.2 软件测试基础</a></li>
        <li><a href="#73-单元测试模块测试">7.3 单元测试（模块测试）</a></li>
        <li><a href="#74-集成测试">7.4 集成测试</a></li>
        <li><a href="#75-确认测试验收测试">7.5 确认测试（验收测试）</a></li>
        <li><a href="#76-白盒测试技术">7.6 白盒测试技术</a></li>
        <li><a href="#77-黑盒测试技术">7.7 黑盒测试技术</a></li>
        <li><a href="#78-调试">7.8 调试</a></li>
        <li><a href="#79-软件可靠性">7.9 软件可靠性</a></li>
      </ul>
    </li>
    <li><a href="#第八章-维护">第八章 维护</a>
      <ul>
        <li><a href="#81-软件维护的定义">8.1 软件维护的定义</a></li>
        <li><a href="#82-软件维护的特点">8.2 软件维护的特点</a></li>
        <li><a href="#83-软件维护过程">8.3 软件维护过程</a></li>
        <li><a href="#84-软件的可维护性">8.4 软件的可维护性</a></li>
        <li><a href="#85-预防性维护">8.5 预防性维护</a></li>
        <li><a href="#86-软件再工程过程">8.6 软件再工程过程</a></li>
      </ul>
    </li>
    <li><a href="#第十三章软件项目管理">第十三章：软件项目管理</a>
      <ul>
        <li><a href="#131-软件项目管理总述">13.1 软件项目管理总述</a></li>
        <li><a href="#132-估算软件规模">13.2 估算软件规模</a></li>
        <li><a href="#133-工作量估算">13.3 工作量估算</a></li>
        <li><a href="#134-进度计划">13.4 进度计划</a></li>
        <li><a href="#135-人员组织">13.5 人员组织</a></li>
        <li><a href="#136-质量保证">13.6 质量保证</a></li>
        <li><a href="#137-软件配置管理">13.7 软件配置管理</a></li>
        <li><a href="#138-能力成熟度模型">13.8 能力成熟度模型</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>

    <div class='content  '>
        <blockquote>
<p>软件工程导论（第六版）学习笔记</p>
</blockquote>
<h2 id="第一章-软件工程学概述">第一章 软件工程学概述</h2>
<h3 id="11-软件危机">1.1 软件危机</h3>
<h4 id="111-软件危机的介绍">1.1.1 软件危机的介绍</h4>
<ul>
<li>软件危机的概念
<ul>
<li>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。</li>
</ul>
</li>
<li>软件危机的典型表现
<ul>
<li>① 对软件开发成本和进度的估计不准确。</li>
<li>② 用户对 “已完成的” 软件系统不满意的现象经常发生。</li>
<li>③ 软件产品的质量往往靠不住。</li>
<li>④ 软件常常是不可维护的。</li>
<li>⑤ 软件通常没有适当的文档资料。</li>
<li>⑥ 软件成本在计算机系统总成本中所占的比例逐年上升。</li>
<li>⑦ 软件开发跟不上计算机应用迅速普及深入的趋势。</li>
</ul>
</li>
</ul>
<h4 id="112-产生软件危机的原因">1.1.2 产生软件危机的原因</h4>
<ul>
<li>客观原因
<ul>
<li>① 软件是计算机系统中的逻辑部件，缺乏 “可见性”，因此管理和控制软件开发过程相当困难。</li>
<li>② 软件维护通常意味着改正或修改原来的设计，因此软件较难维护。</li>
<li>③ 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升。</li>
</ul>
</li>
<li>主观原因
<ul>
<li>① 存在与软件开发和维护有关的许多错误认识和做法。</li>
<li>② 对用户要求没有完整准确的认识就匆忙着手编写程序。</li>
<li>③ 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等）。</li>
<li>④ 软件开发人员轻视维护。</li>
</ul>
</li>
</ul>
<h4 id="113-消除软件危机的途径">1.1.3 消除软件危机的途径</h4>
<ul>
<li>软件
<ul>
<li>软件是程序、数据及相关文档的完整集合</li>
<li>软件＝程序＋数据＋文档。</li>
</ul>
</li>
<li>消除软件危机的途径
<ul>
<li>应该对计算机软件有一个正确的认识，软件 = 程序 + 数据 + 相关文档；</li>
<li>应该充分认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目。</li>
<li>应该推广使用在实践中总结出来的开发软件的成功的技术和方法， 并且研究探索更好更有效的技术和方法。</li>
<li>应该开发和使用更好的软件工具。</li>
</ul>
</li>
</ul>
<h3 id="12-软件工程">1.2 软件工程</h3>
<h4 id="121-软件工程的介绍">1.2.1 软件工程的介绍</h4>
<ul>
<li>软件工程的概念
<ul>
<li>指导计算机软件开发和维护的一门工程学科。</li>
<li>采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来， 以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</li>
</ul>
</li>
<li>软件工程的本质特征
<ul>
<li>① 软件工程关注于大型程序的构造；</li>
<li>② 软件工程的中心课题是控制复杂性；</li>
<li>③ 软件经常变化；</li>
<li>④ 开发软件的效率非常重要；</li>
<li>⑤ 和谐地合作是开发软件的关键；</li>
<li>⑥ 软件必须有效地支持它的用户；</li>
<li>⑦ 软件工程领域由具有一种文化背景的人替具有另一种文化背景的人创造产品。</li>
</ul>
</li>
</ul>
<h4 id="122-软件工程的基本原理">1.2.2 软件工程的基本原理</h4>
<ul>
<li>七条基本原理
<ul>
<li>① 用分阶段的生命周期计划严格管理；</li>
<li>② 坚持进行阶段评审；</li>
<li>③ 实行严格的产品控制；</li>
<li>④ 采用现代程序设计技术；</li>
<li>⑤ 结果应能清楚地审查；</li>
<li>⑥ 开发小组的人员应该少而精；</li>
<li>⑦ 承认不断改进软件工程实践的必要性。</li>
</ul>
</li>
<li>七条基本原理的意义
<ul>
<li>这七条原理是确保软件产品质量和开发效率的原理的最小集合，它们是互相独立的，而且是缺一不可的最小集合，然而这七条原理又是相当完备的。</li>
</ul>
</li>
</ul>
<h4 id="123-软件工程方法学">1.2.3 软件工程方法学</h4>
<ul>
<li>软件工程包括技术和管理两方面的内容。</li>
<li>软件工程是技术与管理紧密结合所形成的工程学科。</li>
<li>软件工程方法学概念
<ul>
<li>通常把软件生命周期全过程中使用的一整套技术方法的集合称为方法学，也称为范型。</li>
<li>目前使用得最广泛的软件工程方法学，分别是传统方法学和面向对象方法学。</li>
</ul>
</li>
<li>软件工程方法学的三要素
<ul>
<li>软件工程方法学包括 3 个要素：方法、工具和过程。</li>
</ul>
</li>
<li>传统方法学（生命周期方法学或结构化范型）
<ul>
<li>① 定义
<ul>
<li>采用结构化技术（结构化分析、结构化设计和结构化实现）来完成软件开发的各项任务，并使用适当的软件工具或软件工程环境来支持结构化技术的运用。</li>
</ul>
</li>
<li>② 优点
<ul>
<li>a. 把软件生命周期划分成若干相对独立、简单的阶段，便于不同人员分工协作，降低开发的困难程度；</li>
<li>b. 开发过程中采用科学的管理技术和良好的技术方法，且在每个阶段结束之前都进行严格的审查，保证了软件的质量，提高了软件的可维护性；</li>
<li>c. 大大提高了软件开发的成功率和生产率。</li>
</ul>
</li>
<li>③ 缺点
<ul>
<li>a. 不适用于软件规模庞大、或者对软件的需求是模糊的或会随时间变化而变化的情况。</li>
<li>b. 结构化范型技术把数据和操作人为地分离成两个独立的部分，增加了软件开发与维护的难度。</li>
</ul>
</li>
</ul>
</li>
<li>面向对象方法学
<ul>
<li>① 定义
<ul>
<li>面向对象方法是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法。</li>
</ul>
</li>
<li>② 要点
<ul>
<li>a. 把对象作为融合了数据及在数据上的操作行为的统一的软件构件；</li>
<li>b. 把所有对象都划分成类；</li>
<li>c. 继承性；</li>
<li>d. 对象彼此间仅能通过发送消息互相联系。</li>
</ul>
</li>
<li>③ 与传统方法学的对比
<ul>
<li>a. 传统方法学强调自顶向下、逐层分解、顺序开发。</li>
<li>b. 面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开发活动之间的平滑过渡。</li>
</ul>
</li>
<li>④ 优点
<ul>
<li>a. 降低了软件产品的复杂性；</li>
<li>b. 提高了软件的可理解性；</li>
<li>c. 简化了软件的开发和维护工作；</li>
<li>d. 提高了软件的可重用性。</li>
</ul>
</li>
<li>【注意】常考面向对象方法学的基本特征：类、继承、封装、多态。结合第 9 章掌握其含义和意义。</li>
</ul>
</li>
</ul>
<h3 id="13-软件生命周期组成">1.3 软件生命周期组成</h3>
<ul>
<li>软件生命周期由软件定义、软件开发、运行维护（软件维护）组成。</li>
<li>软件定义
<ul>
<li>软件定义时期通常进一步划分成 3 个阶段，即问题定义、可行性研究和需求分析。</li>
<li>可行性研究的结果是客户作出是否继续进行这项工程的决定的重要依据</li>
<li>需求分析阶段的重要任务，用正式文档准确记录对目标系统的需求，这份文档为规格说明书</li>
</ul>
</li>
<li>软件开发
<ul>
<li>通常由下述 4 个阶段组成：总体设计，详细设计（模块设计），编码和单元测试，综合测试。</li>
<li>其中前两个阶段又称为系统设计，后两个阶段又称为系统实现。</li>
<li>详细设计是详细设计每个模块，确定实现模块功能所需的算法和数据结构</li>
<li>【注意】考题中常设置选项：在详细设计阶段编写代码。这是错误的， 在编码和单元测试阶段才编写代码。</li>
<li>综合测试阶段中最基本的测试，集成测试和验收测试</li>
</ul>
</li>
<li>运行和维护（软件维护）
<ul>
<li>维护时期主要任务使软件持久地满足用户的需要。</li>
<li>维护活动的分类
<ul>
<li>① 改正性维护；</li>
<li>② 适应性维护；</li>
<li>③ 完善性维护；</li>
<li>④ 预防性维护。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="14-软件过程概念">1.4 软件过程概念</h3>
<ul>
<li>软件过程的定义
<ul>
<li>软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。</li>
</ul>
</li>
<li>软件过程的表示
<ul>
<li>使用生命周期模型简洁地描述软件过程。</li>
</ul>
</li>
<li>软件生命周期模型
<ul>
<li>软件生命周期模型是软件开发的全部过程、活动和任务的结构框 架。软件生命周期模型能清晰、直观地表达软件开发全过程，明确规定了要完成的主要活动和任务，用来作为项目开发的基础。</li>
<li>通常使用生命周期模型简洁地描述软件过程。</li>
<li>软件生命周期模型规定了把生命周期划分为哪些阶段以及各个阶段的执行顺序。</li>
</ul>
</li>
<li>【注意】着重掌握瀑布模型、快速原型模型、螺旋模型、增量模型、喷泉模型。</li>
</ul>
<h4 id="141-瀑布模型">1.4.1 瀑布模型</h4>
<ul>
<li>① 开发流程
<ul>
<li>实际的瀑布模型是带 “反馈环” 的，如图所示（图中实线箭头表示开发过程，虚线箭头表示维护过程）。
<ul>
<li><img src="./imgs/image-20231224103440138.png" alt="image-20231224103440138"></li>
</ul>
</li>
<li>【注意】传统的瀑布模型没有图中的反馈环。
<ul>
<li>
<img src="./imgs/image-20231224103500158.png" alt="image-20231224103500158"  />
</li>
</ul>
</li>
</ul>
</li>
<li>② 特点
<ul>
<li>第一，阶段间具有顺序性和依赖性；</li>
<li>第二，推迟实现的观点；</li>
<li>第三，质量保证的观点。</li>
</ul>
</li>
<li>③ 瀑布模型的优缺点
<ul>
<li>a. 优点
<ul>
<li>第一，可强迫开发人员采用规范的方法；</li>
<li>第二，严格地规定了每个阶段必须提交的文档；</li>
<li>第三，要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证；</li>
<li>第四，对文档的约束，使软件维护变得容易一些，且能降低软件预算。</li>
</ul>
</li>
<li>b. 缺点
<ul>
<li>第一：瀑布模型是由文档驱动的。</li>
<li>第二：缺乏对于需求变更和项目变化的适应性。</li>
<li>第三：用户只有在生命周期的后期才能看到结果；</li>
</ul>
</li>
</ul>
</li>
<li>④ 适用范围
<ul>
<li>适用于用户需求明确、完整、无重大变化的软件项目开发。</li>
</ul>
</li>
</ul>
<h4 id="142-快速原型模型">1.4.2 快速原型模型</h4>
<ul>
<li>① 开发流程
<ul>
<li>如图所示（图中实线箭头表示开发过程，虚线箭头表示维护过程）。</li>
<li>快速原型模型是不带反馈环的。</li>
<li><img src="./imgs/image-20231224103523007.png" alt="image-20231224103523007"></li>
<li>【注意】快速原型模型弥补了瀑布模型不适用于需求动态变更的缺点， 其本质是 “快速”。</li>
</ul>
</li>
<li>② 优点
<ul>
<li>a. 克服了瀑布模型的缺点，对于需求变更具有更好的适应性；</li>
<li>b. 开发费用低、开发周期短且对用户更友好。</li>
</ul>
</li>
<li>③ 缺点
<ul>
<li>a. 客户与开发者对原型理解不同；</li>
<li>b. 本质是快速，没有考虑软件的总体质量和可维护性，最终产品质量较差；</li>
<li>c. 不利于开发人员的创新。</li>
</ul>
</li>
<li>④ 适用范围
<ul>
<li>a．对所开发的领域比较熟悉而且有快速的原型开发工具；</li>
<li>b．项目招投标时，可以以原型模型作为软件的开发模型；</li>
<li>c．进行产品移植或升级时，或对已有产品原型进行客户化工作时。</li>
</ul>
</li>
</ul>
<h4 id="143-增量模型">1.4.3 增量模型</h4>
<ul>
<li>① 开发步骤
<ul>
<li>增量模型也称为渐增模型，如图所示。</li>
<li><img src="./imgs/image-20231224103540502.png" alt="image-20231224103540502"></li>
</ul>
</li>
<li>② 原理
<ul>
<li>把软件产品作为多个增量构件来设计、编码、集成、测试，开发人员一个构件接一个构件地向用户提交产品。</li>
</ul>
</li>
<li>③ 优点
<ul>
<li>a. 能在较短时间内向用户提交可完成部分工作的产品。</li>
<li>b. 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品。</li>
</ul>
</li>
<li>④ 技术难点
<ul>
<li>a. 要求软件体系结构必须是开放的。</li>
<li>b. 增量模型本身是自相矛盾的。</li>
<li>c. 增量模型的灵活性很容易退化为边做边改模型，从而使软件过程的控制失去整体性。</li>
</ul>
</li>
<li>⑤ 风险更大的增量模型
<ul>
<li><img src="./imgs/image-20231224103547671.png" alt="image-20231224103547671"></li>
<li>【注意】每个增量构件的开发采用瀑布模型。</li>
</ul>
</li>
<li>⑥ 适用范围
<ul>
<li>a. 进行已有产品升级或新版本开发；</li>
<li>b. 对完成期限严格要求的产品；</li>
<li>c. 对所开发的领域比较熟悉而且已有原型系统</li>
</ul>
</li>
</ul>
<h4 id="144-螺旋模型">1.4.4 螺旋模型</h4>
<ul>
<li>① 基本思想
<ul>
<li>可以把它看作在每个阶段之前都增加了风险分析过程的快速原型模型， 如图所示。</li>
<li><img src="./imgs/image-20231224103555007.png" alt="image-20231224103555007"></li>
</ul>
</li>
<li>② 原理
<ul>
<li>完整的螺旋模型如图所示。</li>
<li><img src="./imgs/image-20231224103600691.png" alt="image-20231224103600691"></li>
</ul>
</li>
<li>③ 应用
<ul>
<li>螺旋模型主要适用于内部开发的大规模软件项目。</li>
</ul>
</li>
<li>④ 优点
<ul>
<li>a. 有利于已有软件的重用，有助于把软件质量作为软件开发的一个重要目标；</li>
<li>b. 减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险；</li>
<li>c. 在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别。</li>
</ul>
</li>
<li>⑤ 缺点
<ul>
<li>螺旋模型是风险驱动的。要求软件开发人员具有丰富的风险评估经验和这方面的专门知识。</li>
<li>过多的迭代次数会增加开发成本，延迟提交时间。</li>
</ul>
</li>
<li>⑥ 适用范围
<ul>
<li>适用于内部开发的大规模软件项目。</li>
</ul>
</li>
</ul>
<h4 id="145-喷泉模型">1.4.5 喷泉模型</h4>
<ul>
<li>① 开发流程
<ul>
<li>图所示的喷泉模型，是典型的面向对象的软件过程模型之一。</li>
<li><img src="./imgs/image-20231224103612065.png" alt="image-20231224103612065"></li>
</ul>
</li>
<li>② 特点
<ul>
<li>a. 喷泉模型是一种以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程。</li>
<li>b. 体现了面向对象软件开发过程迭代和无缝的特性。</li>
</ul>
</li>
</ul>
<h4 id="146-rational-统一过程rup">1.4.6 Rational 统一过程（RUP）</h4>
<ul>
<li>① RUP 软件开发生命周期
<ul>
<li>RUP 软件开发生命周期是一个二维的面向对象的生命周期模型，如图所示。图中纵轴代表核心工作流，横轴代表时间。</li>
<li><img src="./imgs/image-20231224103617599.png" alt="image-20231224103617599"></li>
</ul>
</li>
<li>② 核心工作流
<ul>
<li>如上图纵轴所示，由上至下有九个核心工作流，前六个为核心过程工作流程，后三个为核心支持工作流程。</li>
</ul>
</li>
<li>③ 工作阶段
<ul>
<li>a. 初始阶段。</li>
<li>b．精化阶段。</li>
<li>c．构建阶段。</li>
<li>d．移交阶段。</li>
</ul>
</li>
<li>④ 特点
<ul>
<li>a. 采用迭代和渐增的方式开发软件。</li>
<li>b. 具有多功能性和广泛适用性。</li>
</ul>
</li>
</ul>
<h4 id="147-敏捷过程">1.4.7 敏捷过程</h4>
<ul>
<li>敏捷过程能够较好地适应商业竞争环境下对小型项目提出的有限资源和有限开发时间的约束。敏捷过程中最重要的是极限编程。</li>
</ul>
<h4 id="148-极限编程">1.4.8 极限编程</h4>
<ul>
<li>① 极限编程的整体开发过程
<ul>
<li>图描述了极限编程的整体开发过程。</li>
<li><img src="./imgs/image-20231224103623526.png" alt="image-20231224103623526"></li>
</ul>
</li>
<li>② 极限编程的迭代过程
<ul>
<li>图描述了极限编程的迭代开发过程。</li>
<li><img src="./imgs/image-20231224103628524.png" alt="image-20231224103628524"></li>
</ul>
</li>
<li>③ 特点
<ul>
<li>a. 以极限编程为代表的敏捷过程，具有对变化和不确定性的更快速、更敏捷的反应特性；</li>
<li>b. 在快速的同时仍然能够保持可持续的开发速度。</li>
</ul>
</li>
</ul>
<h4 id="149-微软过程">1.4.9 微软过程</h4>
<ul>
<li>
<p>① 微软软件生命周期</p>
<ul>
<li>微软过程把软件生命周期划分成五个阶段，图描绘了生命周期的阶段及每个阶段的主要里程碑。</li>
<li><img src="./imgs/image-20231224103634983.png" alt="image-20231224103634983"></li>
</ul>
</li>
<li>
<p>② 微软过程模型</p>
<ul>
<li>
<p>a. 定义</p>
<ul>
<li>微软过程的每一个生命周期发布一个递进的软件版本，各个生命周期持续、快速地迭代循环</li>
<li>图描绘了微软过程的生命周期模型。</li>
<li><img src="./imgs/image-20231224103642078.png" alt="image-20231224103642078"></li>
</ul>
</li>
<li>
<p>b. 特点</p>
<ul>
<li>第一，适用于商业环境下具有有限资源和有限开发时间约束的项目；</li>
<li>第二，微软过程也有某些不足之处，例如，对方法、工具和产品等方面的论述不如 RUP 和敏捷过程全面，人们对它的某些准则本身也有不同意见。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第二章-可行性分析">第二章 可行性分析</h2>
<h3 id="21-可行性研究的任务">2.1 可行性研究的任务</h3>
<ul>
<li>可行性研究的目的
<ul>
<li>用最小的代价在尽可能短的时间内确定问题是否能够解决。</li>
</ul>
</li>
<li>可行性研究的 3 个方面
<ul>
<li>（1）技术可行性；</li>
<li>（2）经济可行性；</li>
<li>（3）操作可行性。</li>
</ul>
</li>
<li>可行性研究的任务
<ul>
<li>（1）对以后的行动方针提出建议。（可行性研究最根本的任务）</li>
<li>（2）分析几种主要的候选解法的利弊，研究其可行性。</li>
</ul>
</li>
</ul>
<h3 id="22-可行性研究过程">2.2 可行性研究过程</h3>
<ul>
<li>典型的可行性研究过程为：
<ol>
<li>复查系统规模和目标；</li>
<li>研究目前正在使用的系统；</li>
<li>导出新系统的高层逻辑模型；</li>
<li>进一步定义问题；</li>
<li>导出并评价供选择的解法；</li>
<li>推荐行动方针；</li>
<li>草拟开发计划；</li>
<li>书写文档提交审查。</li>
</ol>
</li>
</ul>
<h3 id="23-系统流程图">2.3 系统流程图</h3>
<ul>
<li>
<p>定义</p>
<ul>
<li>系统流程图是概括地描绘物理系统的传统工具。系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程。因此尽管系统流程图的符号形式相同，但是它却是物理数据流程图而不是程序流程图。</li>
</ul>
</li>
<li>
<p>基本思想</p>
<ul>
<li>用图形符号以黑盒子形式描绘组成系统的每个部件（程序、文档、数据库、人工过程等）。</li>
<li>【注意】系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程。</li>
</ul>
</li>
<li>
<p>符号</p>
<ul>
<li>
<p>（1）以概括的方式抽象地描绘实际系统时，使用图 2-1 中列出的基本符号就足够了。</p>
<ul>
<li>
<img src="./imgs/image-20231226111137168.png" alt="image-20231226111137168" style="zoom: 80%;" />
</li>
<li>【注意】这 5 种基本符号是常考点。</li>
</ul>
</li>
<li>
<p>（2）需要更具体地描绘一个物理系统时，还需要使用图 2-2 中列出的系统符号。</p>
<ul>
<li>
<img src="./imgs/image-20231226111214255.png" alt="image-20231226111214255" style="zoom:80%;" />
</li>
<li>
<p>【注意】系统流程图的习惯画法是使信息在图中从顶向下或从左向右流动。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><img src="./imgs/f77ebfd028cd407697cbf1dd305cbe0a.png" alt=""></p>
</li>
</ul>
<h3 id="24-数据流图概念">2.4 数据流图概念</h3>
<ul>
<li>
<p>（1）定义</p>
<ul>
<li>数据流图（DFD）是一种图形化技术。它描绘信息流和数据从输入移动到输出的过程中所经受的变换。</li>
</ul>
</li>
<li>
<p>（2）特点</p>
<ul>
<li>① 数据流图中没有具体的物理部件，只是描绘数据在软件中流动和被处理的逻辑过程。</li>
<li>② 数据流图是系统逻辑功能的图形表示，是分析员与用户之间极好的通信工具。</li>
<li>③ 设计时只需考虑系统必须完成的基本逻辑功能，不考虑怎样具体地实现这些功能。</li>
</ul>
</li>
<li>
<p>符号</p>
<ul>
<li>如图（a）所示，数据流图有 4 种基本符号；图（b）给出了附加符号的含义。其中星号（*）表示数据流之间是 “与” 关系；加号（＋）表示 “或” 关系；⊕ 号表示只能从中选一个（互斥的关系）。</li>
<li><img src="./imgs/b4b758719d2a4e9e816f25edc3a6d332.png" alt=""></li>
<li>数据流图有 4 种成分，源点或终点、处理、数据存储、数据流</li>
<li>【注意】数据流中用箭头表示数据流，第 5 章的程序流程图中用箭头表示的控制流。</li>
</ul>
</li>
<li>
<p>数据存储和数据流都是数据，数据存储是处于静止状态的数据，数据流是处理运动中的数据</p>
</li>
<li>
<p>例子</p>
<ul>
<li>
<p><img src="./imgs/222546b8e8974832828d39153ba65373.png" alt=""></p>
</li>
<li>
<p><img src="./imgs/2a8cbb2569ef418fb9de1fd042bda525.png" alt=""></p>
</li>
<li>
<p><img src="./imgs/3461ee48c568436687a16b1a4cdad60d.png" alt=""></p>
</li>
<li>
<p><img src="./imgs/b8ff75647c9a4307b81ce684c6720f80.png" alt=""></p>
</li>
</ul>
</li>
<li>
<p>数据流图的基本目的，利用数据流图作为交流信息的工具</p>
</li>
<li>
<p>数据流图也可用于作为分析和设计的工具</p>
</li>
</ul>
<h3 id="25-数据字典">2.5 数据字典</h3>
<ul>
<li>概念
<ul>
<li>（1）定义
<ul>
<li>数据字典是关于数据的信息的集合，是对数据流图中包含的所有元素的定义的集合。</li>
</ul>
</li>
<li>（2）数据字典的作用
<ul>
<li>在软件分析和设计的过程中给人提供关于数据的描述信息</li>
</ul>
</li>
<li>（3）意义
<ul>
<li>数据流图和数据字典共同构成系统的逻辑模型。</li>
</ul>
</li>
</ul>
</li>
<li>数据字典的组成元素
<ul>
<li>① 数据流；</li>
<li>② 数据流分量，即数据元素；</li>
<li>③ 数据存储；</li>
<li>④ 处理。</li>
</ul>
</li>
<li>定义数据的方法
<ul>
<li>由数据元素组成的数据的方式 3 种基本类型：
<ul>
<li>顺序（3 种基本类型）</li>
<li>选择（3 种基本类型）</li>
<li>重复（3 种基本类型）</li>
<li>可选</li>
</ul>
</li>
<li>描述由数据元素组成数据的关系
<ul>
<li>① = 等价于（定义为）</li>
<li>② + 和（连接两个分量）</li>
<li>③ [] 或（从方括号中的分量选择一个），通常用 “|” 号隔开供选择的分量</li>
<li>④ {} 重复（重复花括号中的分量），字母数字串 = 0{字母或数字}7，允许字母或数字的长度为 0-7</li>
<li>⑤ ( ) 选择（括号中的分量可有可无）</li>
</ul>
</li>
</ul>
</li>
<li>数据字典的用途
<ul>
<li>（1）作为分析阶段的工具（最重要）。</li>
<li>（2）数据字典中包含的每个数据元素的控制信息是很有价值的。</li>
<li>（3）数据字典是开发数据库的第一步，而且是很有价值的一步。</li>
</ul>
</li>
<li>数据字典的实现
<ul>
<li>（1）开发大型软件系统时建议使用数据字典处理程序。</li>
<li>（2）在开发小型软件系统时建议采用卡片形式书写数据字典，如图
<ul>
<li><img src="./imgs/e32a13d424cd4e999788189ccd6d9564.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="26-成本--效益分析">2.6 成本 / 效益分析</h3>
<ul>
<li>
<p>目的</p>
<ul>
<li>帮助客户组织负责人从经济角度判断是否继续投资于这项工程。</li>
</ul>
</li>
<li>
<p>成本估计的方法</p>
<ul>
<li>（1）代码行技术；
<ul>
<li>每行代码的平均成本乘以行数</li>
<li>每行代码的平均成本取决于软件的复杂程度和工资水平</li>
</ul>
</li>
<li>（2）任务分解技术；
<ul>
<li>总成本 = 每个任务成本之和</li>
<li>每个任务的成本 = 人力 (以人月为单位) X 每人每月平均工资</li>
</ul>
</li>
<li>（3）自动估计成本技术。
<ul>
<li>采用自动估计成本的软件工具</li>
</ul>
</li>
</ul>
</li>
<li>
<p>成本效益分析</p>
<ul>
<li>
<blockquote>
<p>成本与收益比较要相同时间的进行比较，现在与现在比较。</p>
</blockquote>
</li>
<li>
<p>计算 P 元钱在 n 年后的价值： F = P ( 1 + i ) n F=P(1+i)^n F=P(1+i)n，其中年利率为 i。</p>
</li>
<li>
<p>n 年后能收入 F 元钱，计算这些钱的现在价值： P = F / ( 1 + i ) n P=F/(1+i)^n P=F/(1+i)n。</p>
<ul>
<li><img src="./imgs/dd06a64bed8c499d9da3b3488802e277.png" alt=""></li>
</ul>
</li>
<li>
<p>投资回收期：使累计的经济效益等于最初投资所需的时间</p>
<ul>
<li><img src="./imgs/bccaca5230314f9093486d71e8b4ef24.png" alt=""></li>
</ul>
</li>
<li>
<p>纯收入</p>
<ul>
<li><img src="./imgs/ab5c2ac9ee824fe2bb1870872448a125.png" alt=""></li>
</ul>
</li>
<li>
<p>计算投资回收率： P = F 1 / ( 1 + j ) + F 2 / ( 1 + j ) 2 + … + F n / ( 1 + j ) n P=F1/(1+j)+F2/(1+j)^2+…+Fn/(1+j)^n P=F1/(1+j)+F2/(1+j)2+…+Fn/(1+j)n</p>
<ul>
<li>其中，P 是现在的投资额；Fi 是第 i 年年底的效益（i ＝ 1，2，…，n）；n 是系统的使用寿命；j 是投资回收率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第三章-需求分析">第三章 需求分析</h2>
<ul>
<li>需求分析是软件定义时期的最后一个阶段，需求分析的基本任务是准确的回答 “系统必须做什么” 这个问题</li>
<li>需求分析阶段系统分析员需要写出软件需求规格说明书</li>
<li>在需求分析阶段通常建立数据模型（实体 - 联系图（ E-R 图））、功能模型（数据流图）、行为模型（状态转换图是行为模型的基础），数据字典成为把 3 种分析模型粘合在一起的 “粘合剂”，是分析模型的核心。</li>
</ul>
<h3 id="31-需求分析的任务">3.1 需求分析的任务</h3>
<ul>
<li>需求分析的定义
<ul>
<li>需求分析是发现、求精、建模、规格说明和复审的过程。</li>
</ul>
</li>
<li>需求分析的必要性
<ul>
<li>为了开发出真正满足用户需求的成功的软件产品，必须知道用户的需求。</li>
</ul>
</li>
<li>需求分析的任务
<ul>
<li>（1）确定对系统的综合要求；
<ul>
<li>（1）功能需求</li>
<li>（2）性能需求</li>
<li>（3）可靠性和可用性需求</li>
<li>（4）出错处理需求</li>
<li>（5）接口需求</li>
<li>（6）约束</li>
<li>（7）逆向需求</li>
<li>（8）将来可能提出的要求</li>
</ul>
</li>
<li>（2）分析系统的数据要求；
<ul>
<li>数据结构表示数据元素之间的逻辑关系</li>
<li>利用数据字典可以全面准确的定义数据（不够形象直观）</li>
<li>在描绘系统中的数据结构，使用层次方框图或 Warnier 图等图形工具。（提高可理解性）</li>
</ul>
</li>
<li>（3）导出系统的逻辑模型；
<ul>
<li>通常使用数据流图、实体 - 联系图、状态转换图、数据字典、主要的处理算法描述逻辑模型</li>
</ul>
</li>
<li>（4）修正系统开发计划。</li>
</ul>
</li>
</ul>
<h3 id="32-与用户沟通获取需求的方法">3.2 与用户沟通获取需求的方法</h3>
<ul>
<li>访谈
<ul>
<li>正式访谈，系统分析员提出事先准备好的具体问题</li>
<li>非正式访谈，分析员提出用户可以自由回答的开放性问题</li>
</ul>
</li>
<li>面向数据流自顶向下求精
<ul>
<li>先建立一个初步的系统功能模型，然后按照基本思想，自顶向下，逐步对顶层数据流图进行细分</li>
<li>结构化分析方法就是面向数据流自顶向下逐步求精进行需求分析的方法</li>
</ul>
</li>
<li>简易的应用规格说明技术
<ul>
<li>进行初步访谈；</li>
<li>开发者和用户分别写出 “产品需求”；</li>
<li>选定会议的时间和地点，选举协调人；</li>
<li>邀请开发者和用户双方组织的代表出席会议；</li>
<li>列出系统环境组成部分的对象、系统将产生的对象、系统为完成自己的功能将使用的对象，列出操作这些对象或与这些对象交互的服务，列出约束条件和性能标准；</li>
<li>共同起草完整的软件需求规格说明书</li>
</ul>
</li>
<li>快速建立软件原型
<ul>
<li>首先通过初步需求，快速建立一个系统原型；然后运行给用户看，用户根据原型提出自己的修改意见，最后程序开发者根据用户的建议，对原型进行修改和完善。如此反复的迭代进行，知道最终建立一个满足用户需求的软件系统为止</li>
<li>特性：快速、容易修改</li>
<li>快速构建和修改原型的方法和工具
<ul>
<li>第四代技术</li>
<li>可重用的软件构件</li>
<li>形式化规格说明和原型环境</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="33-分析建模与规格说明">3.3 分析建模与规格说明</h3>
<ul>
<li>分析建模
<ul>
<li>（1）模型
<ul>
<li>模型由一组图形符号和组织这些符号的规则组成。</li>
<li>为了理解事物而对事物作出的抽象</li>
<li>对事物的一种无歧义的书面描述</li>
</ul>
</li>
<li>（2）建模过程
<ul>
<li>结构化分析实质上是一种创建模型的活动，应从不同的角度抽象目标系统的特性。</li>
</ul>
</li>
<li>实体 - 联系图：描绘数据对象和数据对象之间的关系，用于建立数据模型的图形</li>
<li>数据流图：描绘当数据在软件系统中移动时被交换的逻辑过程，指明系统具有的变换数据的功能，数据流图是建立功能模型的基础</li>
<li>状态转换图：描绘了系统的各种行为模式（称为状态）和在不同状态间转换的方式，状态转换图是行为建模的基础</li>
</ul>
</li>
<li>软件需求规格说明
<ul>
<li>软件需求规格说明书是需求分析阶段得出的最主要的文档。</li>
</ul>
</li>
</ul>
<h3 id="34-实体---联系图e-r-图">3.4 实体 - 联系图（E-R 图）</h3>
<ul>
<li>数据模型的定义
<ul>
<li>概念性数据模型（信息模型）是一种面向问题的数据模型，是按照用户的观点对数据建立的模型。</li>
</ul>
</li>
<li>数据模型的构成</li>
<li>（1）数据对象
<ul>
<li>① 定义
<ul>
<li>数据对象是对软件必须理解的复合信息的抽象。</li>
</ul>
</li>
<li>② 特点
<ul>
<li>a. 可以由一组属性来定义的实体都可以被认为是数据对象。</li>
<li>b. 数据对象彼此间是有关联的。</li>
<li>c. 数据对象只封装了数据而没有对施加于数据上的操作的引用。</li>
</ul>
</li>
</ul>
</li>
<li>（2）数据对象的属性（属性）
<ul>
<li>属性定义了数据对象的性质。</li>
</ul>
</li>
<li>（3）数据对象彼此间相互连接的关系（联系）
<ul>
<li>数据对象彼此之间相互连接的方式称为联系，也称为关系。</li>
<li>联系也可能有属性。</li>
<li>联系可分为以下 3 种类型
<ul>
<li>① 一对一联系（1：1）</li>
<li>② 一对多联系（1：N）</li>
<li>③ 多对多联系（M：N）</li>
</ul>
</li>
</ul>
</li>
<li>实体 - 联系图（E-R 图）
<ul>
<li>实体 - 联系图用于建立数据模型</li>
<li>ER 图描绘的数据模型称为 ER 模型</li>
<li>ER 图的基本成分
<ul>
<li>E-R 图中包含了实体（数据对象）、关系和属性 3 种基本成分</li>
<li>通常用矩形框代表实体</li>
<li>用连接相关实体的菱形框表示关系</li>
<li>用椭圆形或圆角矩形表示实体（或关系）的属性，并用直线把实体（或关系）与其属性连接起来。</li>
</ul>
</li>
<li>优点
<ul>
<li>① E-R 模型比较接近人的习惯思维方式；</li>
<li>② E-R 模型使用简单的图形符号来描述问题，便于用户理解。</li>
</ul>
</li>
<li>ER 模型可以作为用户与分析员之间的交流工具</li>
<li>
<img src="./imgs/image-20231227222231382.png" alt="image-20231227222231382" style="zoom:80%;" />
</li>
</ul>
</li>
</ul>
<h3 id="35-数据规范化">3.5 数据规范化</h3>
<ul>
<li>数据规范化减少数据冗余，避免出现插入异常或删除异常，简化修改数据的过程</li>
<li>使用范式消除数据冗余的程度</li>
</ul>
<h3 id="36-状态转换图">3.6 状态转换图</h3>
<ul>
<li>定义
<ul>
<li>状态转换图（状态图）通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。</li>
</ul>
</li>
<li>状态
<ul>
<li>（1）定义
<ul>
<li>状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。</li>
</ul>
</li>
<li>（2）分类
<ul>
<li>状态主要有：初态（初始状态）、终态（最终状态）和中间状态。</li>
<li>【注意】在一张状态图中只能有一个初态，而终态则可以有 0 至多个。描绘单程生命周期时需要标明初始状态和最终状态</li>
</ul>
</li>
</ul>
</li>
<li>事件
<ul>
<li>事件是在某个特定时刻发生的事情，是对引起系统做动作或从一个状态转换到另一个状态的外界事件的抽象，是引起系统做动作或（和）转换状态的控制信息。</li>
</ul>
</li>
<li>状态图的符号
<ul>
<li>（1）符号的表示方法
<ul>
<li>① 初态：用实心圆表示。</li>
<li>② 终态：用一对同心圆（内圆为实心圆）表示。</li>
<li>③ 中间状态：用圆角矩形表示。可以用两条水平横线把它分成上、中、下 3 个部分。上面部分为状态的名称，这部分是必须有的；中间部分为状态变量的名字和值，下面部分是活动表。</li>
</ul>
</li>
<li>（2）组成部分
<ul>
<li>图给出了状态图中使用的主要组成部分和符号表示。
<ul>
<li>
<img src="./imgs/image-20231227222252980.png" alt="image-20231227222252980" style="zoom:80%;" />
</li>
</ul>
</li>
<li>① 活动表
<ul>
<li>活动表的语法格式为：事件名（参数表）/ 动作表达式</li>
<li>在活动表中经常使用下述 3 种标准事件：entry，exit 和 do。entry 事件指定进入该状态的动作；exit 事件指定退出该状态的动作；do 事件则指定在该状态下的动作。</li>
</ul>
</li>
<li>② 状态转换
<ul>
<li>状态图中两个状态之间带箭头的连线称为状态转换，箭头指明了转换方向。</li>
<li>状态如果由事件触发，需要在状态转换的箭头上标出触发转换的事件表达式，如果不是由事件触发 (执行完内部活动后自动触发) 则不用标明。</li>
</ul>
</li>
<li>③ 事件表达式
<ul>
<li>事件表达式的语法为：事件说明 [守卫条件]/ 动作表达式，其中，事件说明的语法为：事件名（参数表）。</li>
<li>守卫条件是一个布尔表达式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>例子
<ul>
<li>
<img src="./imgs/image-20231227222319321.png" alt="image-20231227222319321" style="zoom:80%;" />
</li>
</ul>
</li>
</ul>
<h3 id="37-其他图形工具">3.7 其他图形工具</h3>
<ul>
<li>
<p>层次方框图</p>
<ul>
<li>层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。</li>
<li>
<img src="./imgs/image-20231227222339792.png" alt="image-20231227222339792" style="zoom:80%;" />
</li>
</ul>
</li>
<li>
<p>Warnier 图</p>
<ul>
<li>Warnier 图有以下三种基本符号：
<ul>
<li>① 花括号：用来区分数据结构的层次，在一个花括号内的所有名字都属于同一类信息。</li>
<li>② 异或符号：表明一类信息或一个数据元素在一定条件下才出现。</li>
<li>③ 圆括号中的数字：指明了这个名字代表的信息类在这个数据结构中重复出现的次数。</li>
</ul>
</li>
<li>
<img src="./imgs/image-20231227222356833.png" alt="image-20231227222356833" style="zoom:80%;" />
</li>
</ul>
</li>
<li>
<p><a href="https://so.csdn.net/so/search?q=IPO%E5%9B%BE&amp;spm=1001.2101.3001.7020">IPO 图</a></p>
</li>
<li>
<p>（1）定义</p>
<ul>
<li>IPO 图是输入、处理、输出图的简称，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。</li>
</ul>
</li>
<li>
<p>（2）基本形式和用法</p>
<ul>
<li>① 左边的框中列出有关的输入数据；</li>
<li>② 中间的框内列出主要的处理；</li>
<li>③ 右边的框内列出产生的输出数据；</li>
<li>④ 粗大箭头指出数据通信的情况。</li>
<li>处理框中列出处理的次序暗示了执行的顺序。</li>
<li>
<img src="./imgs/image-20231227222422462.png" alt="image-20231227222422462" style="zoom:80%;" />
</li>
</ul>
</li>
<li>
<p>（3）改进的 IPO 图</p>
<ul>
<li>改进的 IPO 图（IPO 表）中包含某些附加的信息。如图 3-2 所示，改进的<br>
IPO 图中包含的附加信息主要有系统名称、图的作者，完成的日期，本图描述的模块的名字，模块在层次图中的编号，调用本模块的模块清 单，本模块调用的模块的清单，注释，以及本模块使用的局部数据元素等。</li>
<li>
<img src="./imgs/image-20231227222450824.png" alt="image-20231227222450824" style="zoom:80%;" />
</li>
</ul>
</li>
<li>
<p>【注意】要区分并牢记给定图形工具可用于<a href="https://so.csdn.net/so/search?q=%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;spm=1001.2101.3001.7020">软件生命周期</a>的哪一阶段，此为常考题。本节三种图形工具均可用于需求分析阶段。</p>
</li>
</ul>
<h3 id="38-验证软件需求">3.8 验证软件需求</h3>
<ul>
<li>验证软件需求的正确性
<ul>
<li>（1）验证需求正确性的目的
<ul>
<li>为了提高软件质量，确保软件开发成功，降低软件开发成本。</li>
</ul>
</li>
<li>（2）进行验证的四个方面
<ul>
<li>① 一致性，需求之间不能相互矛盾；</li>
<li>② 完整性，要实现每一个需求；</li>
<li>③ 现实性，指定的需求是在现有的硬件技术和软件技术的基础上可以实现；</li>
<li>④ 有效性，需求可以解决用户面对的问题。</li>
</ul>
</li>
</ul>
</li>
<li>验证软件需求的方法
<ul>
<li>（1）验证需求的一致性；</li>
<li>（2）验证需求的现实性；</li>
<li>（3）验证需求的完整性和有效性。</li>
</ul>
</li>
<li>用于需求分析的软件工具——PSL/PSA 系统
<ul>
<li>① 定义
<ul>
<li>PSL 是用来描述系统的形式语言，PSA 是处理 PSL 描述的分析程序。</li>
</ul>
</li>
<li>② 功能
<ul>
<li>a. 描述任何应用领域的信息系统；</li>
<li>b. 创建一个数据库保存对该信息系统的描述符；</li>
<li>c. 对描述符施加增加、删除和更改等操作；</li>
<li>d. 产生格式化的文档和关于规格说明书的各种分析报告。</li>
</ul>
</li>
<li>③ 优点
<ul>
<li>a. 改进了文档质量，能保证文档具有完整性、一致性和无二义性，从而可以 - 减少管理和维护的费用；</li>
<li>b. 数据存放在数据库中，便于增加、删除和更改。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第五章-总体设计">第五章 总体设计</h2>
<ul>
<li>目的
<ul>
<li>总体设计的基本目的就是回答 “概括地说，系统应该如何实现” 这个问题。</li>
</ul>
</li>
<li>总体设计又称为概要设计或初步设计</li>
<li>主要任务
<ul>
<li>（1）划分出组成系统的物理元素——程序、文件、数据库、人工过程和文档等。</li>
<li>（2）确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系。</li>
<li>【注意】每个物理元素的具体实现是详细阶段的任务。</li>
</ul>
</li>
<li>必要性
<ul>
<li>可以站在全局高度上，以较少的成本选出最佳方案和最合理的软件结构并开发出较高质量的软件系统。</li>
</ul>
</li>
</ul>
<h3 id="51-设计过程">5.1 设计过程</h3>
<ul>
<li>设计过程的两个主要组成阶段
<ul>
<li>（1）系统设计阶段，确定系统的具体实现方案。</li>
<li>（2）结构设计阶段，确定软件结构。</li>
</ul>
</li>
<li>典型的总体设计过程
<ul>
<li>①设想供选择的方案；</li>
<li>②选取合理的方案</li>
<li>③推荐最佳方案</li>
<li>④功能分解</li>
<li>⑤设计软件结构</li>
<li>⑥设计数据库</li>
<li>⑦制定测试计划</li>
<li>⑧书写文档
<ul>
<li>系统说明</li>
<li>用户手册</li>
<li>测试计划</li>
<li>详细的实现计划</li>
<li>数据库设计结果</li>
</ul>
</li>
<li>⑨审查和复查。</li>
</ul>
</li>
</ul>
<h3 id="52-设计原理">5.2 设计原理</h3>
<h4 id="521-模块化">5.2.1 模块化</h4>
<ul>
<li>（1）定义
<ul>
<li>模块化就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。</li>
</ul>
</li>
<li>（2）优点
<ul>
<li>① 使软件结构清晰，不仅容易设计也容易阅读和理解。</li>
<li>② 使软件容易测试和调试，有助于提高软件的可靠性。</li>
<li>③ 提高软件的可修改性。</li>
<li>④ 有助于软件开发工程的组织管理。</li>
</ul>
</li>
<li>【注意】模块是构成程序的基本构件。</li>
</ul>
<h4 id="522-抽象">5.2.2 抽象</h4>
<ul>
<li>（1）定义
<ul>
<li>抽象就是抽出事物的本质特性而暂时不考虑它们的细节。</li>
</ul>
</li>
<li>（2）优点
<ul>
<li>① 简化了软件的设计和实现；</li>
<li>② 提高了软件的可理解性和可测试性；</li>
<li>③ 使得软件更容易维护。</li>
</ul>
</li>
<li>软件工程过程的每一步都是对软件解法的抽象层次的一次精化</li>
</ul>
<h4 id="523-逐步求精">5.2.3 逐步求精</h4>
<ul>
<li>（1）定义
<ul>
<li>定义为：为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。</li>
</ul>
</li>
<li>（2）原理
<ul>
<li>① 逐步求精是一种自顶向下的设计策略。</li>
<li>② 求精实际上是细化过程。</li>
</ul>
</li>
<li>逐步求精如此重要？
<ul>
<li>因为人类的认知过程遵循 Miller 法则，一个人在任何时候都只能把注意力集中在（7+2）个知识块上</li>
</ul>
</li>
<li>抽象与求精是一对互补概念</li>
</ul>
<h4 id="524-信息隐藏和局部化">5.2.4 信息隐藏和局部化</h4>
<ul>
<li>（1）局部化定义
<ul>
<li>指把一些关系密切的软件元素物理地放得彼此靠近。</li>
</ul>
</li>
<li>（2）信息隐藏原理
<ul>
<li>使得一个模块内包含的信息（主要是实现细节）对于不需要这些信息的模块来说，是不能访问的。</li>
</ul>
</li>
<li>局部化有助于信息隐藏</li>
</ul>
<h4 id="525-模块独立">5.2.5 模块独立</h4>
<ul>
<li>（1）定义
<ul>
<li>开发的模块具有独立功能而且和其他模块之间没有过多的相互作用的模块，就可以做到模块独立。</li>
<li>模块独立的概念是模块化、抽象、信息隐藏和局部化的直接结果。</li>
</ul>
</li>
<li>（2）模块的独立程度由两个定性标准衡量：耦合和内聚。</li>
<li>（3）耦合
<ul>
<li>① 定义
<ul>
<li>耦合是对一个软件结构内不同模块之间互连程度的度量。</li>
</ul>
</li>
<li>② 分类
<ul>
<li>a. 完全独立，模块间没有任何连接；</li>
<li>b. 数据耦合，模块之间仅通过交换数据来交换信息；</li>
<li>c．控制耦合，模块之间传递的信息有控制信息；</li>
<li>d．特征耦合，传递的数据为整个数据结构，但只使用其中的一部分数据元素；</li>
<li>e. 公共环境耦合，模块之间通过公共数据环境相互作用；</li>
<li>f. 内容耦合
<ul>
<li>模块访问模块内部数据</li>
<li>模块进入另一个模块没有通过正常入口</li>
<li>模块之间部分程序代码重叠</li>
<li>一个模块有多个入口</li>
</ul>
</li>
<li>数据耦合 &lt; 公共环境耦合 &lt; 特征耦合 &lt; 控制耦合 &lt; 内容耦合（越低越好）</li>
</ul>
</li>
</ul>
</li>
<li>（4）内聚
<ul>
<li>① 定义
<ul>
<li>内聚衡量一个模块内部各个元素彼此结合的紧密程度。</li>
</ul>
</li>
<li>② 分类
<ul>
<li>偶然内聚，模块内任务的关系松散</li>
<li>逻辑内聚，模块完成的任务逻辑上属于相同或类似的一类</li>
<li>时间内聚，模块的任务必须在同一时间段执行</li>
<li>过程内聚，模块内处理元素相关且按一定的次序</li>
<li>通信内聚，模块中所有元素使用同一个输入或产生同一个的输出</li>
<li>顺序内聚，模块中的功能必须顺序执行</li>
<li>功能内聚，模块中所有处理元素属于一个整体，完成一个单一的功能</li>
<li>低内聚（偶然内聚 &lt; 逻辑内聚 &lt; 时间内聚）</li>
<li>中内聚（过程内聚 &lt; 通信内聚）</li>
<li>高内聚（顺序内聚 &lt; 功能内聚）</li>
</ul>
</li>
</ul>
</li>
<li>【注意】：设计的软件尽量满足 “高内聚、低耦合” 和“高扇入、低扇出”原则。</li>
<li>模块独立性比较强的模块应该是具有高内聚性和低耦合度。</li>
<li>在进行软件结构设计时应该遵循的最主要的原理是模块独立原理；</li>
<li>自顶向下逐步求精是进行软件结构设计的常用途径；</li>
<li>抽象和逐步求精是互补的。</li>
</ul>
<h3 id="53-启发规则">5.3 启发规则</h3>
<ul>
<li>改进软件结构提高模块独立性</li>
<li>模块规模应该适中</li>
<li>深度、宽度、扇出和扇入都应适当
<ul>
<li>（1）深度
<ul>
<li>深度表示软件结构中控制的层数。</li>
</ul>
</li>
<li>（2）宽度
<ul>
<li>宽度是软件结构内同一个层次上的模块总数的最大值。宽度越大系统越复杂。对宽度影响最大的因素是模块的扇出。</li>
</ul>
</li>
<li>（3）扇出
<ul>
<li>扇出是一个模块直接控制的模块数目。</li>
</ul>
</li>
<li>（4）扇入
<ul>
<li>扇入表明有多少个上级模块直接调用它。</li>
</ul>
</li>
</ul>
</li>
<li>模块的作用域应该在控制域之内
<ul>
<li>（1）定义
<ul>
<li>① 模块的作用域定义为受该模块内一个判定影响的所有模块的集合。</li>
<li>② 模块的控制域是这个模块本身以及所有直接或间接从属于它的模块的集合。</li>
</ul>
</li>
</ul>
</li>
<li>力争降低模块接口的复杂程度</li>
<li>设计单入口单出口的模块</li>
<li>模块功能应该可以预测</li>
</ul>
<h3 id="54-描绘软件结构的图形工具">5.4 描绘软件结构的图形工具</h3>
<h4 id="541-层次图">5.4.1 层次图</h4>
<ul>
<li>（1）作用
<ul>
<li>层次图用来描绘软件的层次结构。</li>
</ul>
</li>
<li>（2）符号
<ul>
<li>① 矩形框代表一个模块。</li>
<li>② 方框间的连线表示调用关系。</li>
</ul>
</li>
<li>
<img src="./imgs/image-20231230172405503.png" alt="image-20231230172405503" style="zoom:80%;" />
</li>
</ul>
<h4 id="542-hipo-图">5.4.2 HIPO 图</h4>
<ul>
<li>HIPO 图是 “层次图加输入 / 处理 / 输出图” 的缩写。</li>
<li>在层次图里除了最顶层的方框外，每个方框都加了编号。</li>
<li><img src="./imgs/2622dbc31241489992b6b63671d515af.png" alt=""></li>
</ul>
<h4 id="543-结构图">5.4.3 结构图</h4>
<ul>
<li>结构图的符号表示分为两类：</li>
<li>（1）基本符号
<ul>
<li>① 方框代表一个模块，框内注明模块的名字或主要功能；</li>
<li>② 方框之间的箭头（或直线）表示模块的调用关系；</li>
<li>③ 尾部是空心圆的箭头表示传递的是数据，实心圆的箭头表示传递的是控制信息。</li>
<li><img src="./imgs/767af720660e405dbf2eb975ce64f3cf.png" alt=""></li>
</ul>
</li>
<li>（2）特殊符号
<ul>
<li>① 表示当模块 M 中某个判定为真时调用模块 A，为假时调用模块 B，如图所示；</li>
<li><img src="./imgs/c0610753203a40bbaa7a1b12595d255e.png" alt=""></li>
<li>② 表示模块 M 循环调用模块 A、B 和 C，如图所示。</li>
<li><img src="./imgs/f7e20b85183144f787baddce34d24960.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="55-面向数据流的设计方法">5.5 面向数据流的设计方法</h3>
<ul>
<li>面向数据流的设计方法的目标：给出设计软件结构的一个系统化的途径</li>
<li>通常使用数据流图描绘信息在系统中加工和流动的情况</li>
<li>结构化设计方法是基于数据流的设计方法</li>
<li>信息流的类型
<ul>
<li>（1）变换流
<ul>
<li>变换流具有如下特征：
<ul>
<li>① 信息沿输入通路进入系统，同时由外部形式变换成内部形式；</li>
<li>② 进入系统的信息通过变换中心，经加工处理后沿输出通路变成外部形式离开软件系。</li>
</ul>
</li>
<li><img src="./imgs/81331319a59542d587bd175ed4f79bba.png" alt=""></li>
</ul>
</li>
<li>（2）事务流
<ul>
<li>事务流是 “以事务为中心” 的数据流，即数据沿输入通路到达一个处理 T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。</li>
<li>事务流完成接收输入数据、分析每个事务确定事务类型、根据事务选择活动通路的任务</li>
<li><img src="./imgs/0b08cabdbd744942afe7d7f073b3c7bb.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>设计过程
<ul>
<li>下图说明了使用面向数据流方法逐步设计的过程。</li>
<li><img src="./imgs/614912dcd7694fc6a80c7eabece2789d.png" alt=""></li>
<li>【注意】任何设计过程都不是机械的一成不变的。</li>
</ul>
</li>
<li>变换分析
<ul>
<li>变换分析是一系列设计步骤的总称，经过这些步骤把具有变换流特点的数据流图按预先确定的模式映射成软件结构</li>
<li>（1）适用性
<ul>
<li>一般说来，如果数据流不具有显著的事务特点，最好使用变换分析。</li>
</ul>
</li>
<li>（2）设计步骤
<ul>
<li>① 复查基本系统模型；</li>
<li>② 复查并精化数据流图；</li>
<li>③ 确定数据流图具有变换特性还是事务特性；</li>
<li>④ 确定输入流和输出流的边界，从而孤立出变换中心；</li>
<li>⑤ 第一级分解；</li>
<li>⑥ 第二级分解；</li>
<li>⑦ 使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化。</li>
</ul>
</li>
</ul>
</li>
<li>事务分析
<ul>
<li>（1）适用性
<ul>
<li>在数据流具有明显的事务特点时，即有一个明显的事务中心时，采用事务分析方法为宜。</li>
</ul>
</li>
<li>（2）设计
<ul>
<li>事务分析的映射方法如图所示。</li>
<li><img src="./imgs/e05bc9a9babf45358b41348cfac561ac.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>设计优化
<ul>
<li>（1）设计优化时应遵循的原则。
<ul>
<li>① 应该开发能够满足所有功能和性能要求，而且按照设计原理和启发式设计规则衡量是值得接收的软件。</li>
<li>② 应该在设计的早期阶段尽量对软件结构进行精化。</li>
<li>③ 结构简单通常既表示设计风格优雅，又表明效率高。</li>
<li>④ 对于时间是决定性因素的应用场合，可能需要在详细设计阶段或在编写程序的过程中进行优化。</li>
</ul>
</li>
<li>（2）可以采用以下几种方法对时间起决定性作用的软件进行优化。
<ul>
<li>① 在不考虑时间因素的前提下开发并精化软件结构。</li>
<li>② 在详细设计阶段选出最耗费时间的那些模块，仔细地设计它们的处理过程（算法），以求提高效率。</li>
<li>③ 使用高级程序设计语言编写程序。</li>
<li>④ 在软件中孤立出那些大量占用处理机资源的模块。</li>
<li>⑤ 必要时重新设计或用依赖于机器的语言重写上述大量占用资源的模块的代码，以求提高效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第六章-详细设计">第六章 详细设计</h2>
<ul>
<li>详细设计阶段的根本目标：确定应该怎样具体地实现所要求的系统</li>
<li>详细设计阶段的任务不是具体地编写程序</li>
<li>详细设计不仅仅是逻辑上正确地实现每个模块的功能，更重要的是设计出的处理过程应该尽可能简明易懂。</li>
<li>结构程序设计技术是实现详细设计目标的关键技术，也是详细设计的逻辑基础。</li>
</ul>
<h3 id="61-结构程序设计">6.1 结构程序设计</h3>
<ol>
<li>经典定义
<ul>
<li>如果一个程序的代码块仅仅通过顺序、选择和循环这 3 种基本控制结构进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。</li>
</ul>
</li>
<li>程序设计新定义：
<ul>
<li>结构程序设计方法是尽可能少用 GO TO 语句的程序设计方法。</li>
</ul>
</li>
<li>控制结构
<ul>
<li>（1）基本控制结构
<ul>
<li>三种基本的控制结构是 “顺序”“选择” 和“循环”，它们的流程图分别为</li>
<li><img src="./imgs/3fa5269ca56c4c42be7a4c773117a8a7.png" alt=""></li>
<li>【注意】牢记三种基本控制结构，此为常考内容。</li>
<li>3 种基本控制结构保证每个代码块单入口和单出口，结构程序设计是详细设计的逻辑基础。</li>
</ul>
</li>
<li>（2）扩展的控制结构
<ul>
<li>DO UNTIL 和 DO CASE 的流程图分别是</li>
<li><img src="./imgs/b92e753730234374adafeb833c7e8693.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>如果只允许使用顺序、IF_THEN_ELSE 型分支、DO_WHILE 型循环这三种基本控制结构，为经典结构程序设计</li>
<li>还允许使用 DO_CASE 型多分支结构和 DO_UNTIL 型循环结构，为扩展的结构程序设计</li>
<li>如果还允许使用 LEAVE(或 BREAK) 结构，为修正的结构程序设计</li>
</ul>
<h3 id="62-人机界面设计">6.2 人机界面设计</h3>
<ul>
<li>重要性
<ul>
<li>人机界面设计是接口设计的重要组成部分</li>
<li>对于交互式系统来说，人机界面设计和数据设计、体系结构设计及过程设计一样重要。</li>
<li>人机界面的质量直接影响用户对软件产品的接受程度。</li>
</ul>
</li>
<li>设计问题
<ul>
<li>（1）系统响应时间；</li>
<li>（2）用户帮助设施；</li>
<li>（3）出错信息处理；</li>
<li>（4）命令交互。</li>
</ul>
</li>
<li>设计过程
<ul>
<li>用户界面设计是一个迭代的过程，也就是说，通常先创建设计模型，再用原型实现这个设计模型，并由用户试用和评估，然后根据用户意见进行修改。</li>
</ul>
</li>
<li>人机界面设计指南
<ul>
<li>有助于设计者设计出友好、高效的人机界面</li>
<li>一般交互指南</li>
<li>信息显示指南</li>
<li>数据输入指南</li>
</ul>
</li>
</ul>
<h3 id="63-过程设计的工具">6.3 过程设计的工具</h3>
<ul>
<li>过程设计的工具，描述程序处理过程的工具，可以分为图形、表格、语言三类</li>
</ul>
<h4 id="631-程序流程图程序框图">6.3.1 程序流程图（程序框图）</h4>
<ul>
<li>（1）符号表示
<ul>
<li>程序流程图中使用的符号表示如图所示。</li>
<li><img src="./imgs/ca9d6b0762cf47839d4724f928859491.png" alt=""></li>
</ul>
</li>
<li>（2）优点
<ul>
<li>对控制流程的描绘很直观，便于初学者掌握。</li>
</ul>
</li>
<li>（3）缺点
<ul>
<li>① 没遵循逐步求精的原则，它诱使程序员过早地考虑程序的控制流程， 而不去考虑程序的全局结构。</li>
<li>② 程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以随意转移控制。</li>
<li>③ 程序流程图不易表示数据结构。</li>
</ul>
</li>
</ul>
<h4 id="632-盒图n-s-图">6.3.2 盒图（N-S 图）</h4>
<ul>
<li>（1）特点
<ul>
<li>① 功能域明确；</li>
<li>② 不可能任意转移控制；</li>
<li>③ 很容易确定局部和全程数据的作用域；</li>
<li>④ 很容易表示嵌套关系，也可以表示模块的层次结构。</li>
</ul>
</li>
<li>（2）表示
<ul>
<li>下图给出了结构化控制结构的盒图表示，也给出了调用子程序的盒图表示方法。</li>
<li><img src="./imgs/37937ae428734ea5ab83cb8f61aba385.png" alt=""></li>
</ul>
</li>
<li>（3）优点
<ul>
<li>① 盒图没有箭头，因此不允许随意转移控制。</li>
<li>② 盒图可以使程序员逐步养成用结构化的方式思考问题和解决问题的习惯。</li>
</ul>
</li>
</ul>
<h4 id="633-pad-图问题分析图">6.3.3 PAD 图（问题分析图）</h4>
<ul>
<li>（1）符号表示
<ul>
<li>PAD 图用二维树形结构的图来表示程序的控制流，下图给出 PAD 图的基本符号。</li>
<li><img src="./imgs/189cce4779d24efaa0fc2614862f7b7b.png" alt=""></li>
</ul>
</li>
<li>（2）优点
<ul>
<li>① 使用 PAD 符号所设计出来的程序必然是结构化程序。</li>
<li>② PAD 图所描绘的程序结构十分清晰。</li>
<li>③ 用 PAD 图表现程序逻辑，易读、易懂、易记。</li>
<li>④ 容易使用软件工具将 PAD 图自动转换成高级语言源程序，提高了软件可靠性和软件生产率。</li>
<li>⑤ 即可用于表示程序逻辑，也可用于描绘数据结构。</li>
<li>⑥ PAD 图的符号支持自顶向下、逐步求精方法的使用。</li>
</ul>
</li>
<li>【注意】PAD 图中竖线的总条数就是程序的层次数。</li>
<li><img src="./imgs/45e555c12f654f128a778e23c86c28a3.png" alt=""></li>
<li>PAD 图是面向高级程序设计语言的，为每种常用的高级程序设计语言提供了一整套相应的图形符号</li>
</ul>
<h4 id="634-判定表">6.3.4 判定表</h4>
<ul>
<li>（1）适用性
<ul>
<li>算法中包含多重嵌套的条件选择时使用判定表。</li>
<li>判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系</li>
</ul>
</li>
<li>（2）组成
<ul>
<li>① 左上部列出所有条件；</li>
<li>② 左下部是所有可能做的动作；</li>
<li>③ 右上部是表示各种条件组合的一个矩阵；</li>
<li>④ 右下部是和每种条件组合相对应的动作。</li>
<li><img src="./imgs/84e01bc15c7544cbac29023c923b1157.png" alt=""></li>
<li><img src="./imgs/90b3e5115f8a45c0b13b9b45bbdf2942.png" alt=""></li>
<li><img src="./imgs/128c506c7ee5454da93013c041cdeebe.png" alt=""></li>
</ul>
</li>
<li>【注意】判定表右半部的每一列实质上是一条规则，规定了与特定的条件组合相对应的动作。</li>
</ul>
<h4 id="635-判断树">6.3.5 判断树</h4>
<ul>
<li>判定树是判定表的变种，能够清晰地表示复杂的条件组合与应做的动作之间的对应关系</li>
<li><img src="./imgs/9fbf5096dc3a474da86842e57178d1f0.png" alt=""></li>
</ul>
<h4 id="636-过程设计语言">6.3.6 过程设计语言</h4>
<ul>
<li>（1）定义
<ul>
<li>过程设计语言（PDL），即伪码，它是用正文形式表示数据和处理过程的设计工具。</li>
</ul>
</li>
<li>（2）优点
<ul>
<li>① 可作为注释直接插在源程序中，有助于保持文档和程序的一致性，提高文档的质量。</li>
<li>② 可以使用普通的正文编辑程序或文字处理系统，很方便地完成 PDL 的书写和编辑工作。</li>
<li>③ 已经有自动处理 PDL 的程序存在，且可以自动由 PDL 生成程序代码。</li>
</ul>
</li>
<li>（3）缺点
<ul>
<li>不如图形工具形象直观，不如判定表清晰简单。</li>
</ul>
</li>
</ul>
<h3 id="64-面向数据结构的设计方法">6.4 面向数据结构的设计方法</h3>
<h4 id="641-jackson-图">6.4.1 Jackson 图</h4>
<ul>
<li>（1）分类
<ul>
<li>Jackson 图根据程序中数据元素彼此间的逻辑关系可分为顺序结构、选择结构和重复结构 3 类，具体如下：</li>
<li>① 顺序结构
<ul>
<li><img src="./imgs/7e1d0b36e78a41eb90d5b24e4559da47.png" alt=""></li>
<li>【注意】图中每个元素只出现一次，出现的次序依次是 B、C 和 D。</li>
</ul>
</li>
<li>② 选择结构
<ul>
<li><img src="./imgs/9ea57d6e74734bc8bf802b7d1764ca68.png" alt=""></li>
<li>【注意】在 B、C 和 D 的右上角有小圆圈做标记。</li>
</ul>
</li>
<li>③ 重复结构
<ul>
<li><img src="./imgs/3e534669e2fe4d918af588b786a26c8b.png" alt=""></li>
<li>【注意】在 B 的右上角有星号标记。</li>
</ul>
</li>
</ul>
</li>
<li>（2）优点
<ul>
<li>① 便于表示层次结构，而且是对结构进行自顶向下分解的有力工具。</li>
<li>② 形象直观可读性好。</li>
<li>③ 既能表示数据结构也能表示程序结构。</li>
</ul>
</li>
<li>（3）缺点
<ul>
<li>① 图中无法表示选择条件或循环结束条件，影响了图的表达能力，也不易直接把图翻译成程序。</li>
<li>② 框间连线为斜线，不易在行式打印机上输出。</li>
</ul>
</li>
</ul>
<h4 id="642-改进的-jackson-图">6.4.2 改进的 Jackson 图</h4>
<ul>
<li>（1）表示
<ul>
<li>改进的 Jackson 图。</li>
<li><img src="./imgs/7d81b7999e0242c4ad1c27e7112b9e5e.png" alt=""></li>
<li>（a）顺序结构：B、C、D 中任一个都不能是选择出现或重复出现的数据元素。</li>
<li>（b）选择结构：S 右面括号中的数字 i 是分支条件的编号。</li>
<li>（c）可选结构：A 或者是元素 B 或者不出现。</li>
<li>（d）重复结构：循环结束条件的编号为 i。</li>
</ul>
</li>
<li>（2）与层次图的比较
<ul>
<li>① 层次图中的一个方框代表一个模块；而 Jackson 图中一个方框并不代表一个模块。</li>
<li>② 层次图表现的是调用关系；而 Jackson 图表现的是组成关系。</li>
</ul>
</li>
</ul>
<h3 id="65-程序复杂程度的定量度量">6.5 程序复杂程度的定量度量</h3>
<h4 id="651-mccabe-方法">6.5.1 McCabe 方法</h4>
<ul>
<li>（1）流图
<ul>
<li>① 定义
<ul>
<li>流图实质上是 “退化了的” 程序流程图，它仅仅描绘程序的控制流程，完全不表现对数据具体操作以及分支或循环的具体条件。</li>
</ul>
</li>
<li>② 程序流程图映射成流图
<ul>
<li>下图说明了把程序流程图映射成流图的方法。</li>
<li><img src="./imgs/4cfbb8f45ee44397aa430e6719f58ee7.png" alt=""></li>
<li>a. 流图中用圆表示结点，一个圆代表一条或多条语句。程序流程图中的一个顺序的处理框序列和一个菱形判定框，可以映射成流图中的一个结点。</li>
<li>b. 流图中的箭头线称为边，代表控制流。流图中一条边必须终止于一个结点，即使这个结点并不代表任何语句。</li>
<li>c. 由边和结点围成的面积称为区域，计算区域数时应包括图外部未被围起来的区域。</li>
</ul>
</li>
<li>③ PDL 翻译成流图
<ul>
<li>a. 基本情况
<ul>
<li>下图是用 PDL 表示的处理过程及与之对应的流图。</li>
<li><img src="./imgs/8c8e6173d17c4c27a482e86baf907a7b.png" alt=""></li>
</ul>
</li>
<li>b. 包含复合条件
<ul>
<li>复合条件，就是在条件中包含了一个或多个布尔运算符。下图是由包含复合条件的 PDL 片段翻译成的流图。</li>
<li><img src="./imgs/c31446d26dc446ea8956b7c8b910f6d1.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>（2）环形复杂度
<ul>
<li>① 定义
<ul>
<li>McCabe 方法根据程序控制流的复杂程度定量度量程序的复杂程度，度量出的结果称为程序的环形复杂度。</li>
</ul>
</li>
<li>② 计算方法
<ul>
<li>环形复杂度定量度量程序的逻辑复杂度，可以用下述 3 种方法中的任何一种来计算环形复杂度：
<ul>
<li>a. 流图中线性无关的区域数等于环形复杂度。</li>
<li>b. 流图 G 的环形复杂度 V(G)=E-N+2，其中，E 是流图中边的条数，N 是结点数。</li>
<li>c. 流图 G 的环形复杂度 V(G)=P+1，其中，P 是流图中判定结点的数目。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>环形复杂度 V（G）=10 是模块规模的合理上限。</li>
</ul>
<h4 id="652-halstead-方法">6.5.2 Halstead 方法</h4>
<ul>
<li>（1）定义
<ul>
<li>Halstead 方法是根据程序中运算符和操作数的总数来度量程序的复杂程度。</li>
</ul>
</li>
<li>（2）方法
<ul>
<li>① 程序长度 N 定义（N1 为程序中运算符出现的总次数，N2 为操作数出现的总次数）：N=N1+N2；</li>
<li>② 预测程序长度的公式（使用的不同运算符的个数 n1，不同操作数的个数 n2）：H=n1log2(n1)+n2log2(n2)；</li>
<li>③ 预测程序中包含错误的个数的公式：E=Nlog2(n1+n2)/3000。</li>
</ul>
</li>
</ul>
<h2 id="第七章-实现">第七章 实现</h2>
<ul>
<li>通常将编码和测试统称为实现。</li>
</ul>
<h3 id="71-编码">7.1 编码</h3>
<ol>
<li>编码的定义
<ul>
<li>编码是把软件设计结果翻译成用程序设计语言书写的程序。</li>
</ul>
</li>
<li>效率
<ul>
<li>效率主要指处理机时间和存储器容量两个方面。</li>
</ul>
</li>
</ol>
<h3 id="72-软件测试基础">7.2 软件测试基础</h3>
<ul>
<li>软件测试的定义
<ul>
<li>测试是为了发现程序中的错误而执行程序的过程。</li>
</ul>
</li>
<li>测试的目的：
<ul>
<li>在软件投入生产性运行前，尽可能多地发现软件中的错误。</li>
</ul>
</li>
<li>测试的根本任务：发现并改正软件中的错误。</li>
<li>根本目标是尽可能多地发现并排除软件中潜藏的错误，最终把一个高质量的软件系统交给用户使用。</li>
<li>大型软件测试分为单元测试、集成测试和验收测试。</li>
</ul>
<h4 id="721-软件测试的目标">7.2.1 软件测试的目标</h4>
<ul>
<li>（1）测试是为了发现程序中的错误而执行程序的过程。</li>
<li>（2）好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。</li>
<li>（3）成功的测试是发现了至今为止尚未发现的错误的测试。</li>
<li>【注意】测试只能查找出程序中的错误，不能证明程序中没有错误。测试的目标是发现错误，调试的任务是在测试的基础上去改正错误。</li>
</ul>
<h4 id="722-软件测试的准则">7.2.2 软件测试的准则</h4>
<ul>
<li>① 所有的测试都可以追溯至用户需求；</li>
<li>② 测试开始之前就制定测试计划；</li>
<li>③ 把 Pareto 原理应用到软件测试中（测试发现的 80% 很可能是由程序中的 20% 的模块造成的，怎样找出这些可疑的模块）；</li>
<li>④ 从 “小规模” 测试开始，逐步进行 “大规模” 测试；</li>
<li>⑤ 避免穷举测试（把执行路径都检查一遍，不可能做到，执行路径非常庞大）；</li>
<li>⑥ 由独立的第三方从事测试工作以达到最佳的测试效果。</li>
</ul>
<h4 id="723-测试方法">7.2.3 测试方法</h4>
<ul>
<li>（1）白盒测试
<ul>
<li>① 白盒测试（结构测试，已经知道产品的内部工作过程）把程序看成装在一个透明的白盒子里，测试者完全知道程序的结构和处理算法。</li>
<li>② 按照程序内部的逻辑测试程序，检测程序中的主要执行通路是否都能按预定要求正确工作。</li>
</ul>
</li>
<li>（2）黑盒测试
<ul>
<li>① 黑盒测试（功能测试，已经知道产品应该具有的功能）把程序看作一个黑盒子，完全不考虑程序的内部结构和处理过程。</li>
<li>② 黑盒测试是在程序接口进行的测试，只检查程序功能是否能按照规格说明书的规定正常使用。</li>
</ul>
</li>
</ul>
<h4 id="724-测试步骤">7.2.4 测试步骤</h4>
<ul>
<li>（1）单元测试（模块测试）
<ul>
<li>① 定义：单元测试把每个模块作为一个单独的实体来测试，检验其正确性。</li>
<li>② 目的：保证每个模块作为一个单元能正确运行。</li>
<li>【注意】单元测试发现的是编码和详细设计的错误。</li>
</ul>
</li>
<li>（2）子系统测试
<ul>
<li>① 定义：子系统测试把经过单元测试的模块放在一起形成一个子系统来测试。</li>
<li>② 目的：着重测试模块的接口。</li>
</ul>
</li>
<li>（3）系统测试
<ul>
<li>① 定义：系统测试是把经过测试的子系统装配成一个完整的系统来测试。</li>
<li>② 目的：发现设计和编码的错误，并验证系统确实能提供需求说明书中指定的功能。</li>
<li>【注意】子系统测试和系统测试都属于集成测试。</li>
</ul>
</li>
<li>（4）验收测试（确认测试）
<ul>
<li>① 定义：在用户的参与下，把软件系统作为单一的实体，使用实际数据进行测试。</li>
<li>② 目的：验证系统确实能够满足用户的需要。</li>
<li>【注意】验收测试发现的是系统需求说明书中的错误。</li>
</ul>
</li>
<li>（5）平行运行
<ul>
<li>① 定义：同时运行新开发出来的系统和将被它取代的旧系统，以便比较两个系统的处理结果</li>
<li>② 目的：
<ul>
<li>可以在准生产环境中运行新系统而不冒风险</li>
<li>用户可以有一段熟悉新系统的时间</li>
<li>可以验证用户指南和使用手册之类的文档</li>
<li>能够以准生产模式对新系统进行全负荷测试，可以用测试结果验证性能指标</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="725-测试阶段的信息流">7.2.5 测试阶段的信息流</h4>
<ul>
<li>这个阶段的输入信息有：
<ul>
<li>软件配置，包括需求说明书、设计说明书、源程序清单</li>
<li>测试配置，包括测试计划、测试方案</li>
</ul>
</li>
<li><img src="./imgs/988f8d9f4ee14543a459a16917428c84.png" alt=""></li>
</ul>
<h3 id="73-单元测试模块测试">7.3 单元测试（模块测试）</h3>
<ul>
<li>
<p>单元测试：检测软件设计的最小单元——模块</p>
</li>
<li>
<p>单元测试主要使用白盒测试技术。</p>
</li>
<li>
<ol>
<li>测试重点</li>
</ol>
<ul>
<li>着重从下面 5 个方面对模块进行单元测试</li>
<li>（1）模块接口；</li>
<li>（2）局部数据结构；</li>
<li>（3）重要的执行通路；</li>
<li>（4）出错处理通路；</li>
<li>（5）边界条件。</li>
</ul>
</li>
<li>
<ol start="2">
<li>测试方法</li>
</ol>
<ul>
<li>（1）代码审查；</li>
<li>（2）计算机测试。</li>
<li>计算机测试和人工测试（代码审查）各有优缺点互相补充，缺一不可。</li>
</ul>
</li>
<li>
<p>【注意】必须要为每个单元测试开发驱动软件和（或）存根软件。</p>
</li>
</ul>
<h3 id="74-集成测试">7.4 集成测试</h3>
<ul>
<li>集成测试定义：
<ul>
<li>测试和组装软件的系统化技术</li>
<li>在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行集成测试。</li>
<li>子系统测试把模块按照设计要求组装起来的同时进行测试</li>
<li>主要目标是发现与接口有关的问题。</li>
</ul>
</li>
<li>概念
<ul>
<li>（1）模块组装成程序的方法分类
<ul>
<li>① 非渐增式测试：单独测试每个模块，最后合并所有模块进行测试。</li>
<li>② 渐增式测试：每次测试增加一个模块。</li>
</ul>
</li>
<li>（2）非渐增式测试的缺点
<ul>
<li>① 把所有模块放在一起，测试者面对的情况十分复杂。</li>
<li>② 在庞大的程序中诊断定位一个错误非常困难。</li>
<li>③ 一旦改正一个错误之后，又会遇到新的错误，没有穷尽。</li>
</ul>
</li>
<li>（3）渐增式测试的优点
<ul>
<li>① 把程序划分成小段来构造和测试，比较容易定位和改正错误。</li>
<li>② 对接口可以进行更彻底的测试。</li>
<li>③ 可以使用系统化的测试方法。</li>
</ul>
</li>
</ul>
</li>
<li>渐增式测试的策略
<ul>
<li>（1）自顶向下集成
<ul>
<li>从主控制模块（根结点）开始，沿着程序的控制层次向下移动，逐渐把各个模块结合起来，在集成过程中，可以采用宽度优先或深度优先的策略向下推进</li>
<li>包含深度优先和宽度优先两种结合策略。</li>
</ul>
</li>
<li>（2）自底向上集成
<ul>
<li>从 “原子” 模块开始组装和测试，不需要存根，需要驱动程序</li>
</ul>
</li>
</ul>
</li>
<li>两种集成策略的比较
<ul>
<li>（1）自顶向下集成
<ul>
<li>① 优点
<ul>
<li>a. 不需要测试驱动程序。</li>
<li>b．能够在测试阶段的早期实现并验证系统的主要功能。</li>
<li>c．能在早期发现上层模块的接口错误。</li>
</ul>
</li>
<li>② 缺点
<ul>
<li>a．需要存根程序，可能遇到与此相联系的测试困难。</li>
<li>b．低层关键模块中的错误发现较晚。</li>
<li>c．在早期不能充分展开人力。</li>
</ul>
</li>
</ul>
</li>
<li>（2）自底向上集成
<ul>
<li>① 优点
<ul>
<li>a．不需要存根程序，不会遇到与存根程序相联系的测试困难。</li>
<li>b．能较早的发现低层关键模块的错误。</li>
<li>c．能在早期充分展开人力。</li>
</ul>
</li>
<li>② 缺点
<ul>
<li>a．需要测试驱动程序。</li>
<li>b．不能在测试阶段早期实现并验证系统的主要功能。</li>
<li>c．在早期不能发现上层模块的接口错误。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>其他集成测试策略
<ul>
<li>（1）改进的自顶向下测试方法；</li>
<li>（2）混合法。</li>
</ul>
</li>
<li>回归测试
<ul>
<li>（1）定义
<ul>
<li>回归测试是指重新执行已经做过的测试的某个子集，以保证上述这些变化没有带来非预期的副作用。</li>
</ul>
</li>
<li>（2）目的
<ul>
<li>保证由于调试或其他原因引起的变化，不会导致非预期的软件行为或额外错误的测试活动。</li>
</ul>
</li>
<li>（3）回归测试集测试用例：
<ul>
<li>①检测软件全部功能的代表性测试用例；</li>
<li>②专门针对可能受修改影响的软件功能的附加测试；</li>
<li>③针对被修改过的软件成分的测试。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="75-确认测试验收测试">7.5 确认测试（验收测试）</h3>
<ul>
<li>确认测试，也称为验收测试，用户根据需求说明书进行测试</li>
<li>验收测试由最终用户而不是系统的开发者进行。</li>
<li>目标：验证软件的有效性</li>
<li>确认测试通常使用黑盒测试法。</li>
<li>确认测试的重要内容：软件配置复查</li>
<li>确认测试分为 Alpha 测试和 Beta 测试。
<ul>
<li>Alpha 测试：受控制环境下进行</li>
<li>Beta 测试：不受控制环境下进行</li>
</ul>
</li>
</ul>
<h3 id="76-白盒测试技术">7.6 白盒测试技术</h3>
<ul>
<li>设计测试方案是测试阶段的关键技术问题
<ul>
<li>测试方案包括具体的测试目的，应该输入的测试数据和预期的结果</li>
<li>设计测试方案的目的：确定一组最可能发现某个错误或某类错误的测试数据</li>
</ul>
</li>
<li>白盒测试主要使用于早期阶段；</li>
<li>设计白盒测试方案的技术主要有
<ul>
<li>逻辑覆盖，也称为通路测试，有语句覆盖、判定覆盖、条件覆盖、判定 / 条件覆盖、条件组合覆盖、路径覆盖</li>
<li>控制结构测试，基本路径测试和条件测试</li>
</ul>
</li>
<li>逻辑覆盖
<ul>
<li>一组参数过程逐渐进行越来越完整的通路测试</li>
<li>① 语句覆盖
<ul>
<li>语句覆盖的含义是选择足够多的测试数据，使被测程序中每个语句至少执行一次。</li>
</ul>
</li>
<li>② 判定覆盖（分支覆盖）
<ul>
<li>判定覆盖的含义是不仅每个语句必须至少执行一次，而且每个判定的每种可能的结果都应该至少执行一次。</li>
</ul>
</li>
<li>③ 条件覆盖
<ul>
<li>条件覆盖的含义是不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取到各种可能的结果。</li>
</ul>
</li>
<li>④ 判定 / 条件覆盖
<ul>
<li>判定 / 条件覆盖的含义是不仅使得判定表达式中的每个条件都取到各种可能的值，而且每个判定表达式也都取到各种可能的结果。它同时满足判定覆盖和条件覆盖。</li>
</ul>
</li>
<li>⑤ 条件组合覆盖
<ul>
<li>条件组合覆盖要求选取足够多的测试数据，使得每个判定表达式中条件的各种可能组合都至少出现一次。满足条件组合覆盖，也一定满足判定覆盖、条件覆盖和判定 / 条件覆盖标准。</li>
</ul>
</li>
<li>⑥ 点覆盖
<ul>
<li>要求选取足够多的测试数据，使得程序执行路径至少经过流图的每个结点一次。</li>
<li>【注意】点覆盖标准和语句覆盖标准是相同的。</li>
</ul>
</li>
<li>⑦ 边覆盖
<ul>
<li>要求选取足够多测试数据，使程序执行路径至少经过流图中每条边一次。</li>
<li>【注意】边覆盖与判定覆盖是相同的。</li>
</ul>
</li>
<li>⑧ 路径覆盖
<ul>
<li>路径覆盖含义是选取足够多测试数据，使程序的每条可能路径都至少执行一次，如果程序图中有环，则要求每个环至少经过一次。</li>
</ul>
</li>
</ul>
</li>
<li>控制结构测试
<ul>
<li>（1）基本路径测试</li>
<li>【注意】某些独立路径不能以独立的方式测试，即程序的正常流程不能形成独立执行该路径所需要的数据组合。</li>
<li>（2）条件测试</li>
<li>（3）循环测试
<ul>
<li>在结构化的程序中通常只有 3 种循环，即简单循环、串接循环和嵌套循环。</li>
<li><img src="./imgs/34c5c9bf71c3484b9926405847a027c0.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="77-黑盒测试技术">7.7 黑盒测试技术</h3>
<ul>
<li>黑盒测试力图发现的错误：
<ul>
<li>①功能不正确或遗漏了功能；</li>
<li>②界面错误；</li>
<li>③数据结构错误或外部数据库访问错误；</li>
<li>④性能错误；</li>
<li>⑤初始化和终止错误。</li>
</ul>
</li>
<li>黑盒测试主要使用于后期阶段。</li>
<li>设计黑盒测试方案技术主要有，等价划分、边界值分析和错误推测。</li>
<li>等价划分
<ul>
<li>把程序的输入域划分成若干个数据类，选取每个等价类中的一个典型值或任意值作为测试数据。</li>
</ul>
</li>
<li>边界值分析
<ul>
<li>确定边界情况，选取刚好等于、稍小于和稍大于等价类边界值的数据作为测试数据。</li>
</ul>
</li>
<li>错误推测
<ul>
<li>利用判定表或判定树为工具，列出输入数据各种组合与程序应做的动作之间的对应关系，然后为判定表的每一列至少设计一个测试用例。</li>
</ul>
</li>
</ul>
<h3 id="78-调试">7.8 调试</h3>
<ul>
<li>定义
<ul>
<li>调试是在测试发现错误之后排除错误的过程。</li>
<li>调试：定位错误，及时改正错误。</li>
</ul>
</li>
<li>调试途径
<ul>
<li>（1）蛮干法。</li>
<li>（2）回溯法。</li>
<li>（3）原因排除法。
<ul>
<li>① 对分查找法；</li>
<li>② 归纳法；</li>
<li>③ 演绎法。</li>
</ul>
</li>
</ul>
</li>
<li>【注意】务必注意测试和调试的区别。改错是调试的任务，测试的任务是发现错误。</li>
</ul>
<h3 id="79-软件可靠性">7.9 软件可靠性</h3>
<ul>
<li>测试阶段的根本目标是消除错误，保证软件的可靠性</li>
<li>程序中潜藏的错误的数目，直接决定了软件的可靠性</li>
<li>基本概念
<ul>
<li>（1）软件可靠性
<ul>
<li>软件可靠性是程序在给定的时间间隔内，按照规格说明书的规定成功地运行的概率。</li>
</ul>
</li>
<li>（2）软件的可用性
<ul>
<li>软件可用性是程序在给定的时间点，按照规格说明书的规定，成功地运行的概率。</li>
</ul>
</li>
<li>（3）MTTF 和 MTTR
<ul>
<li>① 概念
<ul>
<li>a. 平均维修时间 MTTR
<ul>
<li>表示修复一个故障平均需要用的时间。</li>
</ul>
</li>
<li>b. 平均无故障时间 MTTF
<ul>
<li>表示系统按规格说明书规定成功地运行的平均时间。</li>
</ul>
</li>
</ul>
</li>
<li>② 计算公式
<ul>
<li>如果在一段时间内，软件系统故障停机时间分别为 t d 1 ， t d 2 ， … ， t_{d1}，t_{d2}，…， td1​，td2​，…，正常运行时间分别为 t u 1 ， t u 2 ， … ， t_{u1}，t_{u2}，…， tu1​，tu2​，…，则系统的稳态可用性为：</li>
<li><img src="./imgs/3bf3ad5aa60445b586b5b211176f6b18.png" alt=""></li>
<li>其中：</li>
<li><img src="./imgs/82d75ef46a844b7091fe99dc449746eb.png" alt=""></li>
<li>（7.1）式可以变成</li>
<li><img src="./imgs/add4bf2a325c4d8190057817064ffa04.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>估算平均无故障时间的方法
<ul>
<li>（1）符号
<ul>
<li>① E T E_T ET​：测试之前程序中错误总数；</li>
<li>② I T I_T IT​：程序长度（机器指令总数）；</li>
<li>③ τ τ τ：测试（包括调试）时间；</li>
<li>④ E d (τ) E_d(τ) Ed​(τ)：在 0 至 τ τ τ期间发现的错误数；</li>
<li>⑤ E c (τ) E_c(τ) Ec​(τ)：在 0 至 τ τ τ期间改正的错误数。</li>
</ul>
</li>
</ul>
</li>
<li>（2）基本假定
<ul>
<li>① 单位长度里的错误数 E T E_T ET​/ I T I_T IT​近似为常数。通常 0.5 × 1 0 − 2 0.5×10^{-2} 0.5×10−2≤ E T E_T ET​/ I T I_T IT​≤ 2 × 1 0 − 2 2×10^{-2} 2×10−2。</li>
<li>② 失效率正比于软件中潜藏的错误数，平均无故障时间 MTTF 与剩余的错误数成反比。</li>
<li>③ 假设发现的每一个错误都立即正确地改正了，即 E c (τ) = E d ( τ ) E_c(τ)=E_d(τ) Ec​(τ)=Ed​(τ)。
<ul>
<li>a. 剩余的错误数
<ul>
<li><img src="./imgs/2431fd7c20254bda91c7423518bac511.png" alt=""></li>
</ul>
</li>
<li>b. 单位长度程序中剩余的错误数
<ul>
<li><img src="./imgs/c56295bdf69b4c09b38175b54ea9f8d6.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>（3）估算平均无故障时间
<ul>
<li>① 平均无故障时间与单位长度程序中剩余的错误数成反比（K 经典值为 200），即
<ul>
<li><img src="./imgs/9933cb2aa64449f480d7e0bdee639cb3.png" alt=""></li>
</ul>
</li>
<li>② 估算平均无故障时间的公式，可以评价软件测试进展情况。由（7.5）式可得：
<ul>
<li><img src="./imgs/fb69f860aada4c11a2403779aa426014.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>（4）估计错误总数的方法
<ul>
<li>① 植入错误法
<ul>
<li>假设人为地植入的错误数为 Ns，经过一段时间的测试之后发现 ns 个植入的错误，还发现了 n 个原有的错误。则估计出程序中原有错误的总数为：</li>
<li><img src="./imgs/178a393c06e24b749ff1f5d2b1b93eca.png" alt=""></li>
<li>其中估计出程序中原有错误的总数即是错误总数 E T E_T ET​的估计值。</li>
</ul>
</li>
<li>② 分别测试法
<ul>
<li>假定测试员甲乙发现有标记错误和发现无标记错误的概率相同，则可以估计出测试前程序中的错误总数为：</li>
<li><img src="./imgs/c3623f01065447f3924cbd71cd12066a.png" alt=""></li>
<li>其中，测试员甲发现的错误数为 B 1 B_1 B1​，测试员乙发现的错误数为 B 2 B_2 B2​，两个测试员发现的相同错误数为 b c b_c bc​。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第八章-维护">第八章 维护</h2>
<ul>
<li>维护的基本任务：保证软件在一个相当长的时期能够正常运行</li>
<li>软件工程的主要目的就是要提高软件的可维护性，减少软件维护所需要的工作量，降低软件系统的总成本。</li>
</ul>
<h3 id="81-软件维护的定义">8.1 软件维护的定义</h3>
<ol>
<li>定义
<ul>
<li>软件维护是在软件已经交付使用后，为了改正错误或满足新的需要而修改软件的过程。</li>
</ul>
</li>
<li>分类
<ul>
<li>（1）改正性维护；</li>
<li>（2）适应性维护；</li>
<li>（3）完善性维护；</li>
<li>（4）预防性维护。</li>
</ul>
</li>
</ol>
<h3 id="82-软件维护的特点">8.2 软件维护的特点</h3>
<ul>
<li>结构化维护与非结构化维护差别巨大
<ul>
<li>结构化维护（有一个完整的软件配置）</li>
<li>非结构化维护（内部文档不足）</li>
</ul>
</li>
<li>维护的代价高昂
<ul>
<li>软件维护中无形的代价有：
<ul>
<li>（1）软件维护的费用高昂。</li>
<li>（2）因为可用的资源必须供维护任务使用，以致耽误甚至丧失了开发的良机。</li>
<li>（3）生产率的大幅度下降。</li>
</ul>
</li>
</ul>
</li>
<li>维护的问题很多
<ul>
<li>（1）理解别人写的程序非常困难，而且困难程度随着软件配置成分的减少而迅速增加。</li>
<li>（2）需要维护的软件往往没有合格的文档，或者文档资料显著不足。</li>
<li>（3）当要求对软件进行维护时，不能指望由开发人员给人们仔细说明软件。</li>
<li>（4）绝大多数软件在设计时没有考虑将来的修改。</li>
<li>（5）软件维护不是一项吸引人的工作。</li>
</ul>
</li>
</ul>
<h3 id="83-软件维护过程">8.3 软件维护过程</h3>
<ul>
<li>定义
<ul>
<li>维护过程本质上是修改和压缩了的软件定义和开发过程。</li>
</ul>
</li>
<li>具体过程
<ul>
<li>（1）建立维护组织；</li>
<li>（2）书写维护报告；</li>
<li>（3）规定维护的事件流；
<ul>
<li><img src="./imgs/58890d08d3b3470e85eb57c4d70065b9.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>（4）保存维护记录；</li>
<li>（5）评价维护活动。</li>
</ul>
<h3 id="84-软件的可维护性">8.4 软件的可维护性</h3>
<ul>
<li>定义
<ul>
<li>可维护性指的是维护人员理解、改正、改动或改进这个软件的难易程度。</li>
</ul>
</li>
<li>决定软件可维护性的因素
<ul>
<li>（1）可理解性；</li>
<li>（2）可测试性；</li>
<li>（3）可修改性；</li>
<li>（4）可移植性；</li>
<li>（5）可重用性。</li>
</ul>
</li>
<li>文档
<ul>
<li>（1）重要性
<ul>
<li>文档是影响软件可维护性的决定因素，文档比程序代码更重要。</li>
<li>只有和程序代码完全一致的文档才是真正有价值的文档。</li>
</ul>
</li>
<li>（2）分类
<ul>
<li>软件系统的文档可以分为用户文档和系统文档两类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="85-预防性维护">8.5 预防性维护</h3>
<ul>
<li>定义
<ul>
<li>预防性维护指的是把今天的方法学应用到昨天的系统上，以支持明天的需求。</li>
</ul>
</li>
<li>实质
<ul>
<li>预防性维护实质上是软件再工程。</li>
</ul>
</li>
</ul>
<h3 id="86-软件再工程过程">8.6 软件再工程过程</h3>
<ul>
<li>典型软件再工程模型
<ul>
<li>典型的软件再工程过程模型如图所示。</li>
<li><img src="./imgs/a01f9d6c37aa473b9a57605a33c02a8a.png" alt=""></li>
<li>【注意】在某些情况下这些活动以线性顺序发生，但也并非总是这样。</li>
</ul>
</li>
<li>六类活动
<ul>
<li>（1）库存目录分析；</li>
<li>（2）文档重构；</li>
<li>（3）逆向工程：分析程序，在高于源代码的抽象层次上表示程序的过程。；</li>
<li>（4）代码重构；</li>
<li>（5）数据重构；</li>
<li>（6）正向工程：不仅从现有程序中恢复设计信息，而且使用革新和改造使用信息去改变或重构现有系统。</li>
</ul>
</li>
</ul>
<h2 id="第十三章软件项目管理">第十三章：软件项目管理</h2>
<h3 id="131-软件项目管理总述">13.1 软件项目管理总述</h3>
<h4 id="1-管理">1. 管理</h4>
<ul>
<li>管理是通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以达到既定目标的过程。</li>
</ul>
<h4 id="2-软件项目管理">2. 软件项目管理</h4>
<ul>
<li>软件项目管理先于任何技术活动之前开始，并且贯穿于软件的整个生命周期之中。软件项目管理过程从一组项目计划活动开始，而制定计划的基础是工作量估算和完成期限估算。</li>
</ul>
<h3 id="132-估算软件规模">13.2 估算软件规模</h3>
<h4 id="1-代码行技术">1. 代码行技术</h4>
<ul>
<li>(1) 定义<br>
代码行技术依据以往开发类似产品的经验和历史数据，估计实现一个功能所需要的源程序行数。是一种比较简单的定量估算软件估摸的方法。<br>
(2) 方法<br>
①把实现每个功能的源程序行数累加起来，可得到实现整个软件所需要的源程序行数。<br>
②估计程序的最小规模 (a)、最大规模(b) 和最可能的规模(m), 分别算出这 3 种规模的平均值后，再用下式计算程序规模的估计值：(13.1)<br>
③程序小时用的单位是代码行数 (LOC); 程序大时用的单位是千行代码数 (KLOC)。<br>
(3) 优点<br>
①代码是所有软件开发项目都有的 “产品”, 而且很容易计算代码行数。<br>
②有以往开发类似产品的历史数据可参考时，估计出的数值比较准确。<br>
(4) 缺点<br>
①源程序仅是软件配置的一个成分，用它的规模代表整个软件的规模不太合理。<br>
②用不同语言实现同一个软件所需要的代码行数并不相同。<br>
③不适用于非过程语言。
<ul>
<li>(13.1)<br>
<img src="./imgs/image-20240102113045393.png" alt="image-20240102113045393" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<h4 id="2-功能点技术">2. 功能点技术</h4>
<ul>
<li>(1) 定义<br>
功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软件规模。用功能点 (FP) 为单位度量软件规模。是为了克服代码行技术的缺点，提出来的新技术。<br>
(2) 信息域特性<br>
①输入项数 (Inp): 用户向软件输入的项数，这些输入给软件提供面向应用的数据。<br>
②输出项数 (Out): 软件向用户输出的项数，它们向用户提供面向应用的信息。<br>
③查询数 (Inq): 一次联机输入，它导致软件以联机输出方式产生某种即时响应。<br>
④主文件数 (Maf): 逻辑主文件(数据的一个逻辑组合) 的数目。<br>
⑤外部接口数 (Inf): 机器可读的全部接口数量，用这些接口把信息传送给另一个系统。</li>
</ul>
<h3 id="133-工作量估算">13.3 工作量估算</h3>
<p>软件估算模型使用由经验导出的公式来预测软件开发工作量，工作量是软件规模的函数，工作量的单位通常是人月 (pm)。没有一个估算模型可以适用于所有类型的软件和开发环境。</p>
<h4 id="1-静态单变量模型">1. 静态单变量模型</h4>
<h4 id="2-动态多变量模型">2. 动态多变量模型</h4>
<h4 id="3cocomo2-模型">3.COCOMO2 模型</h4>
<h3 id="134-进度计划">13.4 进度计划</h3>
<h4 id="1-相关概念">1. 相关概念</h4>
<ul>
<li>(1) 任务集合<br>
一个有效的软件过程应该定义一个适用于当前项目的任务集合。一个任务集合包括一组软件工程工作任务、里程碑和可交付的产品。为一个项目所定义的任务集合，必须包括为获得高质量的软件产品而应该完成的所有任务，但是同时又不能让项目组承担不必要的工作。<br>
(2) 项目管理者的工作<br>
①目标<br>
定义全部项目任务，识别出关键任务，跟踪关键任务的进展状况，保证及时发现拖延进度的情况。<br>
②方法<br>
管理者必须制定一个足够详细的进度表，以便监督项目进度并控制整个项目。<br>
(3) 进度安排<br>
①定义<br>
软件项目的进度安排通过把工作量分配给特定的软件工程任务并规定完成各项任务的起止日期，从而将估算出的项目工作量分布于计划好的项目持续期内。进度计划将随着时间的流逝而不断演化。<br>
②流程<br>
a. 在项目计划的早期，制定一个宏观的进度安排表，标识出主要的软件工程活动和这些活动影响到的产品功能。<br>
b. 随着项目的进展，把宏观进度表中的每个条目都精化成一个详细进度表，标识出完成一个活动所必须实现的一组特定任务，并安排好实现这些任务的进度。</li>
</ul>
<h4 id="2-估算开发时间">2. 估算开发时间</h4>
<ul>
<li>P312</li>
</ul>
<h4 id="3gantt-图">3.Gantt 图</h4>
<ul>
<li>
<p>(1) 例子<br>
假设有一座陈旧的矩形木板房需要重新油漆。这项工作必须分 3 步完成：首先刮掉旧漆，然后刷上新漆，最后清除溅在窗户上的油漆。假设一共分配了 15 名工人去完成这项工作，然而工具却很有限：只有 5 把刮旧漆用的刮板，5 把刷漆用的刷子，5 把清除溅在窗户上的油漆用的小刮刀。怎样安排才能使工作进行得更有效呢?<br>
(2) 优点<br>
①很形象地描绘任务分解情况，以及每个子任务 (作业) 的开始时间和结束时间。<br>
②容易掌握、容易绘制。<br>
(3) 缺点<br>
①不能显式地描绘各项作业彼此间的依赖关系。<br>
②进度计划的关键部分不明确，难于判定哪些部分应当是主攻和主控的对象。<br>
③计划中有潜力的部分及潜力的大小不明确，往往造成潜力的浪费。</p>
<ul>
<li>图 13.1 旧木板房刷漆工程的 Gantt 图<br>
<img src="./imgs/image-20240102113452195.png" alt="image-20240102113452195" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<h4 id="4-工程网络">4. 工程网络</h4>
<ul>
<li>(1) 定义<br>
工程网络可以描绘任务分解情况以及每项作业的开始时间和结束时间，它还显式地描绘各个作业彼此间的依赖关系。<br>
(2) 表示<br>
工程网路，如图 13.2 所示。<br>
①用箭头表示作业，作业通常既消耗资源又需要持续一定时间。<br>
②用圆圈表示事件 (开始或结束), 事件是明确定义的时间点，并不消耗时间和资源。<br>
③用虚线箭头表示虚拟作业，虚拟作业是为了显式地表示作业之间的依赖关系。
<ul>
<li>图 13.2 旧木板房刷漆工程的工程网络<br>
<img src="./imgs/image-20240102113513554.png" alt="image-20240102113513554" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
<h4 id="5-估算工程进度">5. 估算工程进度</h4>
<ul>
<li>P316</li>
</ul>
<h4 id="6-关键路径">6. 关键路径</h4>
<ul>
<li>(1) 定义<br>
由最早时刻和最迟时刻相同的事件定义了关键路径。关键事件必须准时发生，组成关键作业的实际持续时间不能超过估计的持续时间，否则工程就不能准时结束。<br>
(2) 特点<br>
①处于关键路径之外的任务进度拖后，不会影响整个项目的完成时间。<br>
②处于关键路径之中的任务进度拖后，则整个项目的完成日期就会拖后。</li>
</ul>
<h4 id="7-机动时间">7. 机动时间</h4>
<ul>
<li>(1) 定义<br>
不在关键路径上的作业有一定程度的机动余地一实际开始时间可以比预定时间晚一些，或者实际持续时间可以比预定的持续时间长一些，而并不影响工程的结束时间。<br>
(2) 计算<br>
一个作业可以有的全部机动时间等于它的结束事件的最迟时刻减去它的开始事件的最早时刻，再减去这个作业的持续时间：<br>
机动时间 =(LET) 结束 -(EET) 开始 - 持续时间<br>
(3) 表示<br>
工程网络中每个作业的机动时间写在该项作业的箭头下面的括号里，如图 13-3 所示。在制定进度计划时仔细考虑和利用工程网络中的机动时间，往往能够安排出既节省资源又不影响最终竣工时间的进度表。</li>
</ul>
<h3 id="135-人员组织">13.5 人员组织</h3>
<h4 id="1-必要性">1. 必要性</h4>
<ul>
<li>(1) 项目成功的关键合理的组织人员，使他们有效地分工协作共同完成开发工作。<br>
(2) 项目组组织得越好，其生产率越高，而且产品质量也越好。<br>
(3) 项目组具有了凝聚力，成功的可能性就大大增加了。</li>
</ul>
<h4 id="2-典型的组织方式">2. 典型的组织方式</h4>
<p>现有的软件项目组的组织方式很多，通常，组织软件开发人员的方法，取决于所承担的项目的特点、以往的组织经验以及管理者的看法和爱好，主要有 3 种典型的组织方式。</p>
<ul>
<li>
<p>(1) 民主制程序员组<br>
①定义<br>
民主制程序员组中小组成员完全平等，享有充分民主，通过协商做出技术决策。即小组成员之间的通信是平行的，如果小组内有 n 个成员，则可能的通信信道共有 n(n-1)/2 条。<br>
②要求<br>
a. 小组的人数不能太多 (2～8 名成员为宜)<br>
小组规模小，可以减少通信问题、容易确定小组的质量标准、用民主方式确定的标准更容易被大家遵守、组员间关系密切、能够互相学习。<br>
b. 采用非正式的组织方式<br>
名义上有一个组长，但是他和组内其他成员完成同样的任务。在这样的小组中，由全体讨论协商决定应该完成的工作，并且根据每个人的能力和经验分配适当的任务。<br>
③优点<br>
a. 组员们对发现程序错误持积极的态度，有助于更快速地发现错误，提高代码质量。<br>
b. 组员们享有充分民主，小组凝聚力高、学术空气浓厚，有利于攻克技术难关。<br>
④缺点<br>
没有明确的权威指导开发过程，组员间将缺乏必要的协调，最终可能导致工程失败。<br>
⑤适用性<br>
所要开发的软件的技术难度较高时，采用民主制程序员组是适宜的。</p>
</li>
<li>
<p>(2) 主程序员组</p>
<ul>
<li>
<p>①定义<br>
主程序员组用经验多、技术好、能力强的程序员作为主程序员，同时，利用人和计算机在事务性工作方面给主程序员提供充分支持，而且所有通信都通过一两个人进行。典型的主程序员组的组织形式如图 13.5 所示。<br>
②核心人员及其分工<br>
a. 主程序员<br>
既是成功的管理人员又是经验丰富、技术好、能力强的高级程序员，负责体系结构设计和关键部分的详细设计，并且负责指导其他程序员完成详细设计和编码工作。<br>
b. 后备程序员<br>
技术熟练而且富于经验，协助主程序员工作并且在必要时接替主程序员的工作。具体工作是设计<a href="https://so.csdn.net/so/search?q=%E6%B5%8B%E8%AF%95%E6%96%B9%E6%A1%88&amp;spm=1001.2101.3001.7020">测试方案</a>、分析测试结果及独立于设计过程的其他工作。<br>
c. 编程秘书<br>
负责完成与项目有关的全部事务性工作。<br>
注意：图 13.5 介绍的是 20 世纪 70 年代初期的主程序员组组织结构，现在的情况已经和当时大不相同了，程序员已经有了自己的终端或<a href="https://so.csdn.net/so/search?q=%E5%B7%A5%E4%BD%9C%E7%AB%99&amp;spm=1001.2101.3001.7020">工作站</a>，他们自己完成代码的输入、编辑、编译、链接和调试等工作，无须由编程秘书统一做这些工作。<br>
③特点 (优点)<br>
a. 专业化：该组每名成员仅完成他们擅长的工作。<br>
b. 层次性：主程序员指挥组员工作，并对项目全面负责<br>
④缺点<br>
符合主程序员、后备程序员、编辑秘书标准的人才在现实社会中并不容易雇佣到。<br>
⑤适用性<br>
采用主程序员组这种组织方式的程序一般具有以下几方面的特点：<br>
a. 软件开发人员多数比较缺乏经验。<br>
b. 程序设计过程中有许多事务性的工作。<br>
c. 多渠道通信很费时间，将降低程序员的生产率。</p>
<ul>
<li>图 13.5 主程序员组的结构<br>
<img src="./imgs/image-20240102113539527.png" alt="image-20240102113539527" style="zoom:80%;" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p>(3) 现代程序员组</p>
<ul>
<li>①主程序员由两个人共同担任<br>
a. 技术负责人<br>
负责小组的技术活动，参与全部代码审查工作，并且对代码的各方面质量负责。<br>
b. 行政负责人<br>
负责非技术性事务的管理决策。不参与代码审查，其职责是对程序员的业绩进行评价。<br>
②制定针对公共职责范围内的事务的处理方案<br>
③实行分组策略<br>
采用分组策略，如图 13.7 所示。产品开发作为一个整体是在项目经理的指导下进行的，程序员向他们的组长汇报工作，而组长则向项目经理汇报工作。当产品规模更大时，可以适当增加中间管理层次。<br>
④分散决定<br>
在合适的地方采用分散做决定的方法，如图 13.8 所示。这样做有利于形成畅通的通信渠道，以便充分发挥每个程序员的积极性和主动性，集思广益攻克技术难关。
<ul>
<li>
<p>图 13.6 现代程序员组的结构<br>
<img src="./imgs/image-20240102113558365.png" alt="image-20240102113558365" style="zoom:80%;" /></p>
</li>
<li>
<p>图 13.7 大型项目的技术管理组织结构<br>
<img src="./imgs/image-20240102113709934.png" alt="image-20240102113709934" style="zoom:80%;" /></p>
</li>
<li>
<p>图 13.8 包含分散决策的组织方式<br>
<img src="./imgs/image-20240102113726894.png" alt="image-20240102113726894" style="zoom:80%;" /></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="136-质量保证">13.6 质量保证</h3>
<h4 id="1-软件质量">1. 软件质量</h4>
<ul>
<li>
<p>(1) 定义<br>
软件质量是软件与明确地和隐含地定义的需求相一致的程度，即软件质量是软件与明确地叙述的功能和性能需求、文档中明确描述的开发标准以及任何专业开发的软件产品都应该具有的隐含特征相一致的程度。<br>
(2) 特点<br>
①软件需求是度量软件质量的基础，与需求不一致就是质量不高。<br>
②指定的开发标准定义了指导软件开发准则，没有遵守这些准则，会导致软件质量不高。<br>
③软件满足明确描述的需求，但不满足隐含的需求，那么软件的质量是值得怀疑的。<br>
(3) 软件质量因素与产品活动<br>
①软件质量因素<br>
如表 13.7 所示，列出了软件质量因素的简明定义。<br>
②产品活动<br>
可以把产品活动 (倾向) 分为产品运行、产品修改和产品转移。<br>
③关系<br>
软件质量因素和 3 种产品活动 (倾向) 之间的关系，如图 13.9 所示。</p>
<ul>
<li>
<p>表 13.7 软件质量因素的定义<br>
<img src="./imgs/image-20240102113914374.png" alt="image-20240102113914374" style="zoom:80%;" /></p>
</li>
<li>
<p>图 13.9 软件质量因素与产品活动的关系<br>
<img src="./imgs/image-20240102113959901.png" alt="image-20240102113959901" style="zoom:80%;" /></p>
</li>
</ul>
</li>
</ul>
<h4 id="2-软件质量保证措施">2. 软件质量保证措施</h4>
<ul>
<li>(1) 措施<br>
①基于非执行的测试 (复审或评审): 主要用来保证在编码前各阶段产生的文档的质量。<br>
②基于执行的测试 (软件测试): 在程序编写完后进行， 保证软件质量的最后一道防线。<br>
③程序正确性证明：使用数学方法严格验证程序是否与对它的说明完全一致。<br>
(2) 参加软件质量保证的人员分类<br>
①软件工程师：用先进的技术方法和度量，进行复审以及完成软件测试来保证软件质量。<br>
②SQA 小组：辅助软件工程师以获得高质量的软件产品。其从事的软件质量保证活动的主要是：计划，监督，记录，分析和报告，它通过确保软件过程的质量来保证软件产品的质量。<br>
(3) 技术复审<br>
正式技术复审的优点是能较早发现软件错误，防止错误被传播到软件过程的后续阶段。包括走查和审查等具体方法。<br>
①走查<br>
a. 走查组<br>
走查组由 4～6 名成员组成。成员包括负责起草文档的人、负责该文档说明的管理员、客户代表、下阶段开发组的代表、SQA 小组的代表 (作为组长)。<br>
b. 要点<br>
第一，为了能发现重大错误，走查组成员最好是经验丰富的高级技术人员。<br>
第二，走查组成员应根据材料并列出不理解的术语和认为不正确的术语。<br>
第三，走查组组长引导该组成员走查文档，力求发现尽可能多的错误。<br>
第四，走查的时间最长不要超过 2 小时。<br>
c. 方式<br>
第一，参与者驱动法<br>
参与者按照事先准备好的列表，提出他们不理解的术语和认为不正确的术语。文档编写组的代表必须回答每个质疑。<br>
第二，文档驱动法 (更有效)<br>
文档编写者向走查组成员仔细解释文档。走查组成员在此过程中针对事先准备好的问题或解释过程中发现的问题提出质疑。<br>
②审查<br>
a. 审查组<br>
查组由 4 人组成，分别是组长 (既是管理人员又是技术负责人)、负责当前阶段开发工作的项目组代表、负责下一阶段开发工作的项目组代表、SQA 小组的代表。<br>
b. 步骤<br>
第一，综述<br>
由负责编写文档的成员向审查组综述该文档。<br>
第二，准备<br>
评审员仔细阅读文档。<br>
第三，审查<br>
评审组仔细走查整个文档。<br>
第四，返工<br>
文档的作者负责解决在审查报告中列出的所有错误及问题。<br>
第五，跟踪<br>
组长必须确保所提出的每个问题都得到了圆满的解决。<br>
c. 与走查比较<br>
第一，审查过程步数比走查多。<br>
第二，审查过程每个步骤都是正规的仔细划分错误类型，并把这些信息运用在后续阶段的文档审查中以及未来产品的审查中。<br>
d. 重要性<br>
审查是检测软件错误的一种好方法，利用审查可以在软件过程的早期阶段 (修改成本低的阶段) 发现并改正错误，即审查是一种经济有效的错误检测方法。<br>
注意：走查的步骤比审查少，没有审查正规。<br>
(4) 程序正确性证明<br>
①定义<br>
正确性证明的基本思想是证明程序能完成预定的功能。应提供对程序功能的严格数学说明，然后根据程序代码证明程序确实能实现它的功能说明。<br>
②方法<br>
a. 人工证明程序正确性<br>
对于评价小程序可能有些价值，但在证明大型软件的正确性时，不仅工作量太大，而且在证明的过程中很容易包含错误。<br>
b. 自动系统</li>
</ul>
<h3 id="137-软件配置管理">13.7 软件配置管理</h3>
<h4 id="1-相关概念-1">1. 相关概念</h4>
<ul>
<li>(1) 定义<br>
软件配置管理是在软件的整个生命期内管理变化的一组活动。其主要任务是控制变化，同时也负责各个软件配置项和软件各种版本的标识、软件配置审计以及对软件配置发生的任何变化的报告。<br>
(2) 目的<br>
软件配置管理不同于软件维护，它的目标是使变化更正确且更容易被适应，在必须变化时减少所需花费的工作量。具体如下：<br>
①标识变化；<br>
②控制变化；<br>
③确保适当地实现了变化；<br>
④向需要知道这类信息的人报告变化。<br>
(3) 与维护的区别<br>
维护是在软件交付给用户使用后才发生的，而配置管理是在软件项目启动时就开始，并且一直持续到软件退役后才终止的一组跟踪和控制活动。</li>
</ul>
<h4 id="2-软件配置">2. 软件配置</h4>
<ul>
<li>(1) 软件配置项<br>
软件过程的输出信息可以分为 3 类：<br>
①计算机程序 (源代码和可执行程序)。<br>
②描述计算机程序的文档 (供技术人员或用户使用)。<br>
③数据 (程序内包含的或在程序外的)。<br>
(2) 基线<br>
①定义<br>
基线是已经通过了正式复审的规格说明或中间产品，它可以作为进一步开发的基础，并且只有通过正式的变化控制过程才能改变它，即基线就是通过了正式复审的软件配置项。<br>
②作用<br>
基线有助于人们在不严重妨碍合理变化的前提下来控制变化。<br>
(3) 软件工具<br>
把特定版本的编辑器、编译器和其他 CASE 工具，作为软件配置的一部分。为防止不同版本的工具产生结果不同，应把软件工具也基线化，并且列入到综合的配置管理过程之中。</li>
</ul>
<h4 id="3-软件配置管理过程">3. 软件配置管理过程</h4>
<ul>
<li>软件配置管理是软件质量保证的重要一环，它的主要任务是控制变化，同时也负责各个软件配置项和软件各种版本的标识、软件配置审计以及对软件配置发生的任何变化的报告，具体来说，软件配置管理主要有 5 项任务标识、版本控制、变化控制、配置审计和报告。<br>
(1) 标识软件配置中的对象<br>
①对象分类<br>
a. 基本对象：是软件工程师在分析、设计、编码或测试过程中创建出来的 “文本单元”。<br>
b. 聚集对象：是基本对象和其他聚集对象的集合。<br>
②要点<br>
a. 每个对象都有一组能唯一地标识它的特征：名字、描述、资源表和实现。<br>
b. 对象名是无二义性地标识该对象的一个字符串。<br>
c. 标识模式必须能无歧义地标识每个对象的不同版本。<br>
(2) 版本控制<br>
①定义<br>
版本控制使用规程和工具，以管理在软件工程过程中所创建的配置对象的不同版本。<br>
②目标<br>
借助于版本控制技术，用户能通过选择适当的版本来指定软件系统的配置。<br>
③步骤<br>
a. 把属性和软件的每个版本关联起来。<br>
b. 描述一组所期望的属性 (施加到系统上的功能变化的具体类型) 来指定和构造所需要的配置。<br>
(3) 变化控制<br>
①定义<br>
变化控制把人的规程和自动工具结合起来，以提供一个控制变化的机制。<br>
②过程<br>
a. 评估该变化在技术方面的得失、可能产生的副作用、对其他配置对象和系统功能的整体影响以及估算出<br>
的修改成本。<br>
b. 根据评估结果形成变化报告，供变化控制审批者审阅。<br>
c. 为每个被批准的变化都生成一个工程变化命令，描述将要实现的变化，必须遵守的约束以及复审和审计的标准。<br>
d. 把要修改的对象从项目数据库中提取出来，进行修改并应用适当的 SQA 活动。<br>
e. 把修改后的对象提交进数据库，用适当的版本控制机制创建该软件的下一个版本。<br>
③主要功能<br>
a. 访问控制：决定哪个软件工程师有权访问和修改一个特定的配置对象。<br>
b. 同步控制：助于保证由两名不同的软件工程师完成的并行修改不会相互覆盖。<br>
(4) 配置审计<br>
①正式的技术复审<br>
正式的技术复审关注被修改后的配置对象的技术正确性。复审者审查该对象以确定它与其他软件配置项的一致性，并检查是否有遗漏或副作用。<br>
②软件配置审计<br>
软件配置审计通过评估配置对象的那些通常不在复审过程中考虑的特征，而成为对正式技术复审的补充。<br>
(5) 状态报告<br>
①内容<br>
a. 发生的事件。<br>
b. 做的这件事的人。<br>
c. 事件是发生的时间。<br>
d. 产生的影响。<br>
②作用<br>
配置状态报告对大型软件开发项目的成功有重大贡献。配置状态报告通过改善所有相关人员之间的通信，帮助消除由于通信不精确、不及时所产生的严重问题。</li>
</ul>
<h3 id="138-能力成熟度模型">13.8 能力成熟度模型</h3>
<h4 id="1-能力成熟度模型-cmm">1. 能力成熟度模型 (CMM)</h4>
<ul>
<li>(1) 定义<br>
能力成熟度模型 (CMM) 是用于评价软件机构的软件过程能力成熟度的模型。<br>
(2) 目的<br>
①为大型软件项目的招投标活动提供一种全面而客观的评审依据。<br>
②应用于许多软件机构内部的过程改进活动中。<br>
(3) 基本思想<br>
能力成熟度模型的基本思想是，由于问题是由人们管理软件过程的方法不当引起的，所以新软件技术的运用并不会自动提高软件的生产率和质量。<br>
(4) 作用<br>
能力成熟度模型有助于软件开发机构建立一个有规律的、成熟的软件过程。改进后的软件过程将开发出质量更好的软件，使更多的软件项目免受时间延误和费用超支之苦。<br>
(5)CMM 在改进软件过程中所起的作用<br>
①指导软件机构通过确定当前的过程成熟度并识别出对过程改进起关键作用的问题，明确过程改进的方向和策略。<br>
②通过集中开展与过程改进的方向和策略相一致的一组过程改进活动，软件机构便能稳步而有效地改进其软件过程，使其软件过程能力得到循序渐进的提高。<br>
(6) 对能力成熟度划分的原因<br>
①对软件过程的改进，是在完成一个又一个小的改进步骤基础上不断进行的渐进过程。<br>
②这 5 个成熟度等级定义了一个有序的尺度，用以测量软件机构的软件过程成熟度和评价其软件过程能力，这些等级还帮助软件机构把应做的改进工作排出优先次序。<br>
③成熟度等级是妥善定义的向成熟软件机构前进途中的平台，每个成熟度等级都为软件过程的继续改进提供了一个台阶。</li>
</ul>
<h4 id="2-能力成熟度的-5-个等级">2. 能力成熟度的 5 个等级</h4>
<ul>
<li>(1) 内容<br>
①反映出软件机构为了达到从无序的、混乱的软件过程进化到有序的、有纪律的且成熟的软件过程的目的，必须经历的过程改进活动的途径。<br>
②每个成熟度级别都是该软件机构沿着改进其过程的途径前进途中的一个台阶，后一个成熟度级别是前一个级别的软件过程的进化目标。<br>
③每个成熟度级别中都包含一组过程改进的目标，满足这些目标后一个机构的软件过程就从当前级别进化到下一个成熟度级别。<br>
(2)5 个级别<br>
①初始级 (1 级)<br>
软件过程能力是不可预测的，其软件过程是不稳定的，产品质量只能根据相关人员的个人工作能力来预测。<br>
②可重复级 (2 级)<br>
软件项目的策划和跟踪是稳定的，已经为一个有纪律的管理过程提供了可重复以前成功实践的项目环境。<br>
③已定义级 (3 级)<br>
无论是管理活动还是工程活动都是稳定的。软件开发的成本和进度以及产品的功能和质量都受到控制，而且软件产品的质量具有可追溯性。<br>
④已管理级 (4 级)<br>
软件机构对软件过程和软件产品都建立了定量的质量目标，所有项目的重要的过程活动都是可度量的，软件过程在可度量的范围内运行。<br>
⑤优化级 (5 级)<br>
软件机构能够不断地改进其过程能力，既对现行的过程实例不断地改进和优化，又借助于新技术和新方法来实现未来的过程改进。这一级的软件机构是一个以防止出现缺陷为目标的机构，它有能力识别软件过程要素的薄弱环节，并有足够的手段改进它们。</li>
</ul>

    </div>
    
    

    

</div>

        </div>
        <div id="footer"><div class="container-footer">
    
    

    <div class="beian">
        
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=">
            

        </a>

        <a href="//tryanel.github.io/days/" target="_blank">
            
            明天，我们会更好
            
        </a>
    </div>

    <div class="info">
        <a href="https://github.com/Tryanel/Tryanel.github.io">Copyright</a> © 2023 - <span id="info-date"></span>
    </div>

</div></div>
        <div class="cool-after" style=""></div>
    </body>
</html>
