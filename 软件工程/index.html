<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="软件工程 - https://Tryanel.github.io/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">
    <meta name="author" content="Cat - https://Tryanel.github.io/">
    
    <meta name="msvalidate.01" content="B46311949B856F2A7015F366FB3CE878" />
    <title>软件工程</title>
    <link rel="icon" type="image/png" href="/favicon.ico">
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-webfont/1.7.0/style.min.css" />
    <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" />
    
    <link rel="stylesheet" href="https://Tryanel.github.io/style.min.6bbccf0916939df698171c34d30f896276712c30bd56be0d7fd8023e1b00c3d9.css">
    
    <script type="text/javascript" src="/main.js" defer></script>
    
</head>
<body class="active-animate cool">
        <div class="cool-before" style="background: url('/imgs/bg/Snipaste_2023-12-09_21-22-04.png') center center/cover no-repeat fixed;"></div>
        <div id="header" class=""><div class="container-header">
    
    
    <div class="right">
        
        <h1 class="title">软件工程</h1>
    
        
            
            <div id="toc">📜</div>
        
    </div>
</div>
</div>
        <div id="content">










<div class="container-main container-page ">

    <div class="desc">
        
        <span>
            
            <svg t="1656736000388" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7409" width="12" height="12"><path d="M524.885333 338.986667L200.362667 663.466667c-17.28 15.274667-27.989333 36.693333-29.696 56.234666v133.76l130.730666 0.085334c22.784-1.621333 43.989333-12.245333 61.013334-31.701334l322.688-322.645333-160.213334-160.213333z m60.373334-60.330667l160.170666 160.213333 102.144-102.144a19.712 19.712 0 0 0 0-27.861333L715.093333 176.426667a19.456 19.456 0 0 0-27.605333 0L585.258667 278.613333zM701.312 85.333333c27.946667 0 54.741333 11.136 74.282667 30.848l132.309333 132.309334a105.045333 105.045333 0 0 1 0 148.565333L424.874667 879.957333c-29.824 34.346667-72.106667 55.466667-120.448 58.794667H85.333333v-42.666667l0.128-179.84c3.626667-44.970667 24.576-86.826667 56.448-114.944l485.12-485.034666A104.789333 104.789333 0 0 1 701.269333 85.333333z" p-id="7410" fill="#adb5bd"></path></svg>
            2023-12-13&nbsp;&nbsp;&nbsp;
            <svg t="1656737270708" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23838" width="11" height="11"><path d="M824.264 95.36c0-23.859 25.043-44.16 48.902-44.16s49.714 20.301 49.714 44.16v190.08c0 23.859-19.054 52.868-42.913 52.868h-190.08c-23.859 0-46.696-25.96-46.696-49.819s22.55-46.249 46.409-46.249h82.025C702.344 175.534 610.22 155.853 512 155.853c-206.775 0-360.398 149.372-360.398 356.147 0 206.775 153.623 358.23 360.398 358.23 206.775 0 357.467-151.455 357.467-358.23 0-23.859 23.634-50.706 53.413-50.706 29.78 0 49.92 26.847 49.92 50.706 0 254.493-206.307 460.8-460.8 460.8-254.493 0-460.8-206.307-460.8-460.8C51.2 257.507 257.507 51.2 512 51.2c122.4 0 226.684 33.296 312.264 117.369 0.358 0.351 0.358-24.052 0-73.209z" p-id="23839" fill="#adb5bd"></path></svg>
            2023-12-27&nbsp;&nbsp;&nbsp;
        </span>
        <span>
            
            <svg t="1656737548689" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="33866" width="12" height="12"><path d="M832.038608 64.662657H192.030028C121.255125 64.662657 63.940169 121.98845 63.940169 192.694717v446.793671C63.940169 710.205493 121.255125 767.643272 192.030028 767.643272h133.353183a63.940169 63.940169 0 0 1 55.219742 31.576328l76.099638 129.83828c12.358154 21.093031 33.790754 31.626903 55.216129 31.626903s42.832688-10.544709 55.198067-31.619678l76.222461-129.870792a63.940169 63.940169 0 0 1 55.212517-31.551041h133.54103c70.576219 0 127.732228-57.289669 127.732227-127.800865V192.391272C959.825022 121.85479 902.643727 64.662657 832.038608 64.662657zM895.884854 639.842407A63.85347 63.85347 0 0 1 832.092795 703.703103h-133.54103a127.753903 127.753903 0 0 0-110.349172 63.09847l-76.222461 129.856342a0.274545 0.274545 0 0 1 0-0.050574h-0.032512s-0.021675 0.061411-0.032512 0.061412l-76.1466-129.85273A127.804477 127.804477 0 0 0 325.383211 703.703103H192.030028A64.207489 64.207489 0 0 1 127.880338 639.488388V192.694717A64.102729 64.102729 0 0 1 192.030028 128.602826h640.00858A63.799284 63.799284 0 0 1 895.884854 192.391272v447.451135z" fill="#adb5bd" p-id="33867"></path><path d="M608.154093 288.092004A31.970084 31.970084 0 0 0 576.184009 320.062089v160.078006l-134.650049-179.278119A31.970084 31.970084 0 0 0 384.002258 320.062089v255.760676a31.970084 31.970084 0 0 0 63.940169 0v-159.958796l134.650048 179.274507a31.970084 31.970084 0 0 0 57.531703-19.200113V320.062089a31.970084 31.970084 0 0 0-31.970085-31.970085z" fill="#adb5bd" p-id="33868"></path></svg>
            12804 字</span>&nbsp;
        <span>
            
            <svg t="1656737462334" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="32892" width="12" height="12"><path d="M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667z m0 810.666666c-204.8 0-373.333333-168.533333-373.333333-373.333333S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z" p-id="32893" fill="#adb5bd"></path><path d="M695.466667 567.466667l-151.466667-70.4V277.333333c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v238.933334c0 12.8 6.4 23.466667 19.2 29.866666l170.666667 81.066667c4.266667 2.133333 8.533333 2.133333 12.8 2.133333 12.8 0 23.466667-6.4 29.866666-19.2 6.4-14.933333 0-34.133333-17.066666-42.666666z" p-id="32894" fill="#adb5bd"></path></svg>
            26 分钟</span>
            <div class="container-ctgtag">
	<div class="taxonomy">
		<div class="tag">
			
			
			<a href="/tags/%E8%AE%A1%E7%A7%91">计科</a>
			
		</div>
	</div>
</div>
        
    </div>
    
    <div class="toc">
        <div class="container-page-operation">
	<div class="page-operation">
		<div><a href="/"><img src="/imgs/icons/home-2.svg" alt=""></a></div>
		<div><a href="/nav"><img src="/imgs/icons/iov-navigate-1.svg" alt=""></a></div>
		<div><a href="/tags"><img src="/imgs/icons/treetags.svg" alt=""></a></div>
		<div id="light-dark"><a><img src="/imgs/icons/moon2.svg" alt=""></a></div>
		<div><a href="#"><img src="/imgs/icons/up2.svg" alt=""></a></div>
	</div>
</div>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#第一章-软件工程学概述">第一章 软件工程学概述</a>
      <ul>
        <li><a href="#11-软件危机">1.1 软件危机</a></li>
        <li><a href="#12-软件工程">1.2 软件工程</a></li>
        <li><a href="#13-软件生命周期组成">1.3 软件生命周期组成</a></li>
        <li><a href="#14-软件过程概念">1.4 软件过程概念</a></li>
      </ul>
    </li>
    <li><a href="#第二章-可行性分析">第二章 可行性分析</a>
      <ul>
        <li><a href="#21-可行性研究的任务">2.1 可行性研究的任务</a></li>
        <li><a href="#22-可行性研究过程">2.2 可行性研究过程</a></li>
        <li><a href="#23-系统流程图">2.3 系统流程图</a></li>
        <li><a href="#24-数据流图概念">2.4 数据流图概念</a></li>
        <li><a href="#25-数据字典">2.5 数据字典</a></li>
        <li><a href="#26-成本--效益分析">2.6 成本 / 效益分析</a></li>
      </ul>
    </li>
    <li><a href="#第三章-需求分析">第三章 需求分析</a>
      <ul>
        <li><a href="#31-需求分析的任务">3.1 需求分析的任务</a></li>
        <li><a href="#32-与用户沟通获取需求的方法">3.2 与用户沟通获取需求的方法</a></li>
        <li><a href="#33-分析建模与规格说明">3.3 分析建模与规格说明</a></li>
        <li><a href="#34-实体---联系图e-r-图">3.4 实体 - 联系图（E-R 图）</a></li>
        <li><a href="#35-数据规范化">3.5 数据规范化</a></li>
        <li><a href="#36-状态转换图">3.6 状态转换图</a></li>
        <li><a href="#37-其他图形工具">3.7 其他图形工具</a></li>
        <li><a href="#38-验证软件需求">3.8 验证软件需求</a></li>
      </ul>
    </li>
    <li><a href="#第五章-总体设计">第五章 总体设计</a>
      <ul>
        <li><a href="#51-设计过程">5.1 设计过程</a></li>
        <li><a href="#52-设计原理">5.2 设计原理</a></li>
        <li><a href="#53-启发规则">5.3 启发规则</a></li>
        <li><a href="#54-描绘软件结构的图形工具">5.4 描绘软件结构的图形工具</a></li>
        <li><a href="#55-面向数据流的设计方法">5.5 面向数据流的设计方法</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>

    <div class='content  '>
        <blockquote>
<p>软件工程导论（第六版）学习笔记</p>
</blockquote>
<h2 id="第一章-软件工程学概述">第一章 软件工程学概述</h2>
<h3 id="11-软件危机">1.1 软件危机</h3>
<h4 id="111-软件危机的介绍">1.1.1 软件危机的介绍</h4>
<ul>
<li>软件危机的概念
<ul>
<li>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。</li>
</ul>
</li>
<li>软件危机的典型表现
<ul>
<li>① 对软件开发成本和进度的估计不准确。</li>
<li>② 用户对 “已完成的” 软件系统不满意的现象经常发生。</li>
<li>③ 软件产品的质量往往靠不住。</li>
<li>④ 软件常常是不可维护的。</li>
<li>⑤ 软件通常没有适当的文档资料。</li>
<li>⑥ 软件成本在计算机系统总成本中所占的比例逐年上升。</li>
<li>⑦ 软件开发跟不上计算机应用迅速普及深入的趋势。</li>
</ul>
</li>
</ul>
<h4 id="112-产生软件危机的原因">1.1.2 产生软件危机的原因</h4>
<ul>
<li>客观原因
<ul>
<li>① 软件是计算机系统中的逻辑部件，缺乏 “可见性”，因此管理和控制软件开发过程相当困难。</li>
<li>② 软件维护通常意味着改正或修改原来的设计，因此软件较难维护。</li>
<li>③ 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升。</li>
</ul>
</li>
<li>主观原因
<ul>
<li>① 存在与软件开发和维护有关的许多错误认识和做法。</li>
<li>② 对用户要求没有完整准确的认识就匆忙着手编写程序。</li>
<li>③ 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等）。</li>
<li>④ 软件开发人员轻视维护。</li>
</ul>
</li>
</ul>
<h4 id="113-消除软件危机的途径">1.1.3 消除软件危机的途径</h4>
<ul>
<li>软件
<ul>
<li>软件是程序、数据及相关文档的完整集合</li>
<li>软件＝程序＋数据＋文档。</li>
</ul>
</li>
<li>消除软件危机的途径
<ul>
<li>应该对计算机软件有一个正确的认识，软件 = 程序 + 数据 + 相关文档；</li>
<li>应该充分认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目。</li>
<li>应该推广使用在实践中总结出来的开发软件的成功的技术和方法， 并且研究探索更好更有效的技术和方法。</li>
<li>应该开发和使用更好的软件工具。</li>
</ul>
</li>
</ul>
<h3 id="12-软件工程">1.2 软件工程</h3>
<h4 id="121-软件工程的介绍">1.2.1 软件工程的介绍</h4>
<ul>
<li>软件工程的概念
<ul>
<li>指导计算机软件开发和维护的一门工程学科。</li>
<li>采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来， 以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</li>
</ul>
</li>
<li>软件工程的本质特征
<ul>
<li>① 软件工程关注于大型程序的构造；</li>
<li>② 软件工程的中心课题是控制复杂性；</li>
<li>③ 软件经常变化；</li>
<li>④ 开发软件的效率非常重要；</li>
<li>⑤ 和谐地合作是开发软件的关键；</li>
<li>⑥ 软件必须有效地支持它的用户；</li>
<li>⑦ 软件工程领域由具有一种文化背景的人替具有另一种文化背景的人创造产品。</li>
</ul>
</li>
</ul>
<h4 id="122-软件工程的基本原理">1.2.2 软件工程的基本原理</h4>
<ul>
<li>七条基本原理
<ul>
<li>① 用分阶段的生命周期计划严格管理；</li>
<li>② 坚持进行阶段评审；</li>
<li>③ 实行严格的产品控制；</li>
<li>④ 采用现代程序设计技术；</li>
<li>⑤ 结果应能清楚地审查；</li>
<li>⑥ 开发小组的人员应该少而精；</li>
<li>⑦ 承认不断改进软件工程实践的必要性。</li>
</ul>
</li>
<li>七条基本原理的意义
<ul>
<li>这七条原理是确保软件产品质量和开发效率的原理的最小集合，它们是互相独立的，而且是缺一不可的最小集合，然而这七条原理又是相当完备的。</li>
</ul>
</li>
</ul>
<h4 id="123-软件工程方法学">1.2.3 软件工程方法学</h4>
<ul>
<li>软件工程包括技术和管理两方面的内容。</li>
<li>软件工程是技术与管理紧密结合所形成的工程学科。</li>
<li>软件工程方法学概念
<ul>
<li>通常把软件生命周期全过程中使用的一整套技术方法的集合称为方法学，也称为范型。</li>
<li>目前使用得最广泛的软件工程方法学，分别是传统方法学和面向对象方法学。</li>
</ul>
</li>
<li>软件工程方法学的三要素
<ul>
<li>软件工程方法学包括 3 个要素：方法、工具和过程。</li>
</ul>
</li>
<li>传统方法学（生命周期方法学或结构化范型）
<ul>
<li>① 定义
<ul>
<li>采用结构化技术（结构化分析、结构化设计和结构化实现）来完成软件开发的各项任务，并使用适当的软件工具或软件工程环境来支持结构化技术的运用。</li>
</ul>
</li>
<li>② 优点
<ul>
<li>a. 把软件生命周期划分成若干相对独立、简单的阶段，便于不同人员分工协作，降低开发的困难程度；</li>
<li>b. 开发过程中采用科学的管理技术和良好的技术方法，且在每个阶段结束之前都进行严格的审查，保证了软件的质量，提高了软件的可维护性；</li>
<li>c. 大大提高了软件开发的成功率和生产率。</li>
</ul>
</li>
<li>③ 缺点
<ul>
<li>a. 不适用于软件规模庞大、或者对软件的需求是模糊的或会随时间变化而变化的情况。</li>
<li>b. 结构化范型技术把数据和操作人为地分离成两个独立的部分，增加了软件开发与维护的难度。</li>
</ul>
</li>
</ul>
</li>
<li>面向对象方法学
<ul>
<li>① 定义
<ul>
<li>面向对象方法是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法。</li>
</ul>
</li>
<li>② 要点
<ul>
<li>a. 把对象作为融合了数据及在数据上的操作行为的统一的软件构件；</li>
<li>b. 把所有对象都划分成类；</li>
<li>c. 继承性；</li>
<li>d. 对象彼此间仅能通过发送消息互相联系。</li>
</ul>
</li>
<li>③ 与传统方法学的对比
<ul>
<li>a. 传统方法学强调自顶向下、逐层分解、顺序开发。</li>
<li>b. 面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开发活动之间的平滑过渡。</li>
</ul>
</li>
<li>④ 优点
<ul>
<li>a. 降低了软件产品的复杂性；</li>
<li>b. 提高了软件的可理解性；</li>
<li>c. 简化了软件的开发和维护工作；</li>
<li>d. 提高了软件的可重用性。</li>
</ul>
</li>
<li>【注意】常考面向对象方法学的基本特征：类、继承、封装、多态。结合第 9 章掌握其含义和意义。</li>
</ul>
</li>
</ul>
<h3 id="13-软件生命周期组成">1.3 软件生命周期组成</h3>
<ul>
<li>软件生命周期由软件定义、软件开发、运行维护（软件维护）组成。</li>
<li>软件定义
<ul>
<li>软件定义时期通常进一步划分成 3 个阶段，即问题定义、可行性研究和需求分析。</li>
<li>可行性研究的结果是客户作出是否继续进行这项工程的决定的重要依据</li>
<li>需求分析阶段的重要任务，用正式文档准确记录对目标系统的需求，这份文档为规格说明书</li>
</ul>
</li>
<li>软件开发
<ul>
<li>通常由下述 4 个阶段组成：总体设计，详细设计（模块设计），编码和单元测试，综合测试。</li>
<li>其中前两个阶段又称为系统设计，后两个阶段又称为系统实现。</li>
<li>详细设计是详细设计每个模块，确定实现模块功能所需的算法和数据结构</li>
<li>【注意】考题中常设置选项：在详细设计阶段编写代码。这是错误的， 在编码和单元测试阶段才编写代码。</li>
<li>综合测试阶段中最基本的测试，集成测试和验收测试</li>
</ul>
</li>
<li>运行和维护（软件维护）
<ul>
<li>维护时期主要任务使软件持久地满足用户的需要。</li>
<li>维护活动的分类
<ul>
<li>① 改正性维护；</li>
<li>② 适应性维护；</li>
<li>③ 完善性维护；</li>
<li>④ 预防性维护。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="14-软件过程概念">1.4 软件过程概念</h3>
<ul>
<li>软件过程的定义
<ul>
<li>软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。</li>
</ul>
</li>
<li>软件过程的表示
<ul>
<li>使用生命周期模型简洁地描述软件过程。</li>
</ul>
</li>
<li>软件生命周期模型
<ul>
<li>软件生命周期模型是软件开发的全部过程、活动和任务的结构框 架。软件生命周期模型能清晰、直观地表达软件开发全过程，明确规定了要完成的主要活动和任务，用来作为项目开发的基础。</li>
<li>通常使用生命周期模型简洁地描述软件过程。</li>
<li>软件生命周期模型规定了把生命周期划分为哪些阶段以及各个阶段的执行顺序。</li>
</ul>
</li>
<li>【注意】着重掌握瀑布模型、快速原型模型、螺旋模型、增量模型、喷泉模型。</li>
</ul>
<h4 id="141-瀑布模型">1.4.1 瀑布模型</h4>
<ul>
<li>① 开发流程
<ul>
<li>实际的瀑布模型是带 “反馈环” 的，如图所示（图中实线箭头表示开发过程，虚线箭头表示维护过程）。
<ul>
<li><img src="./imgs/image-20231224103440138.png" alt="image-20231224103440138"></li>
</ul>
</li>
<li>【注意】传统的瀑布模型没有图中的反馈环。
<ul>
<li>
<img src="./imgs/image-20231224103500158.png" alt="image-20231224103500158"  />
</li>
</ul>
</li>
</ul>
</li>
<li>② 特点
<ul>
<li>第一，阶段间具有顺序性和依赖性；</li>
<li>第二，推迟实现的观点；</li>
<li>第三，质量保证的观点。</li>
</ul>
</li>
<li>③ 瀑布模型的优缺点
<ul>
<li>a. 优点
<ul>
<li>第一，可强迫开发人员采用规范的方法；</li>
<li>第二，严格地规定了每个阶段必须提交的文档；</li>
<li>第三，要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证；</li>
<li>第四，对文档的约束，使软件维护变得容易一些，且能降低软件预算。</li>
</ul>
</li>
<li>b. 缺点
<ul>
<li>第一：瀑布模型是由文档驱动的。</li>
<li>第二：缺乏对于需求变更和项目变化的适应性。</li>
<li>第三：用户只有在生命周期的后期才能看到结果；</li>
</ul>
</li>
</ul>
</li>
<li>④ 适用范围
<ul>
<li>适用于用户需求明确、完整、无重大变化的软件项目开发。</li>
</ul>
</li>
</ul>
<h4 id="142-快速原型模型">1.4.2 快速原型模型</h4>
<ul>
<li>① 开发流程
<ul>
<li>如图所示（图中实线箭头表示开发过程，虚线箭头表示维护过程）。</li>
<li>快速原型模型是不带反馈环的。</li>
<li><img src="./imgs/image-20231224103523007.png" alt="image-20231224103523007"></li>
<li>【注意】快速原型模型弥补了瀑布模型不适用于需求动态变更的缺点， 其本质是 “快速”。</li>
</ul>
</li>
<li>② 优点
<ul>
<li>a. 克服了瀑布模型的缺点，对于需求变更具有更好的适应性；</li>
<li>b. 开发费用低、开发周期短且对用户更友好。</li>
</ul>
</li>
<li>③ 缺点
<ul>
<li>a. 客户与开发者对原型理解不同；</li>
<li>b. 本质是快速，没有考虑软件的总体质量和可维护性，最终产品质量较差；</li>
<li>c. 不利于开发人员的创新。</li>
</ul>
</li>
<li>④ 适用范围
<ul>
<li>a．对所开发的领域比较熟悉而且有快速的原型开发工具；</li>
<li>b．项目招投标时，可以以原型模型作为软件的开发模型；</li>
<li>c．进行产品移植或升级时，或对已有产品原型进行客户化工作时。</li>
</ul>
</li>
</ul>
<h4 id="143-增量模型">1.4.3 增量模型</h4>
<ul>
<li>① 开发步骤
<ul>
<li>增量模型也称为渐增模型，如图所示。</li>
<li><img src="./imgs/image-20231224103540502.png" alt="image-20231224103540502"></li>
</ul>
</li>
<li>② 原理
<ul>
<li>把软件产品作为多个增量构件来设计、编码、集成、测试，开发人员一个构件接一个构件地向用户提交产品。</li>
</ul>
</li>
<li>③ 优点
<ul>
<li>a. 能在较短时间内向用户提交可完成部分工作的产品。</li>
<li>b. 逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品。</li>
</ul>
</li>
<li>④ 技术难点
<ul>
<li>a. 要求软件体系结构必须是开放的。</li>
<li>b. 增量模型本身是自相矛盾的。</li>
<li>c. 增量模型的灵活性很容易退化为边做边改模型，从而使软件过程的控制失去整体性。</li>
</ul>
</li>
<li>⑤ 风险更大的增量模型
<ul>
<li><img src="./imgs/image-20231224103547671.png" alt="image-20231224103547671"></li>
<li>【注意】每个增量构件的开发采用瀑布模型。</li>
</ul>
</li>
<li>⑥ 适用范围
<ul>
<li>a. 进行已有产品升级或新版本开发；</li>
<li>b. 对完成期限严格要求的产品；</li>
<li>c. 对所开发的领域比较熟悉而且已有原型系统</li>
</ul>
</li>
</ul>
<h4 id="144-螺旋模型">1.4.4 螺旋模型</h4>
<ul>
<li>① 基本思想
<ul>
<li>可以把它看作在每个阶段之前都增加了风险分析过程的快速原型模型， 如图所示。</li>
<li><img src="./imgs/image-20231224103555007.png" alt="image-20231224103555007"></li>
</ul>
</li>
<li>② 原理
<ul>
<li>完整的螺旋模型如图所示。</li>
<li><img src="./imgs/image-20231224103600691.png" alt="image-20231224103600691"></li>
</ul>
</li>
<li>③ 应用
<ul>
<li>螺旋模型主要适用于内部开发的大规模软件项目。</li>
</ul>
</li>
<li>④ 优点
<ul>
<li>a. 有利于已有软件的重用，有助于把软件质量作为软件开发的一个重要目标；</li>
<li>b. 减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险；</li>
<li>c. 在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别。</li>
</ul>
</li>
<li>⑤ 缺点
<ul>
<li>螺旋模型是风险驱动的。要求软件开发人员具有丰富的风险评估经验和这方面的专门知识。</li>
<li>过多的迭代次数会增加开发成本，延迟提交时间。</li>
</ul>
</li>
<li>⑥ 适用范围
<ul>
<li>适用于内部开发的大规模软件项目。</li>
</ul>
</li>
</ul>
<h4 id="145-喷泉模型">1.4.5 喷泉模型</h4>
<ul>
<li>① 开发流程
<ul>
<li>图所示的喷泉模型，是典型的面向对象的软件过程模型之一。</li>
<li><img src="./imgs/image-20231224103612065.png" alt="image-20231224103612065"></li>
</ul>
</li>
<li>② 特点
<ul>
<li>a. 喷泉模型是一种以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程。</li>
<li>b. 体现了面向对象软件开发过程迭代和无缝的特性。</li>
</ul>
</li>
</ul>
<h4 id="146-rational-统一过程rup">1.4.6 Rational 统一过程（RUP）</h4>
<ul>
<li>① RUP 软件开发生命周期
<ul>
<li>RUP 软件开发生命周期是一个二维的面向对象的生命周期模型，如图所示。图中纵轴代表核心工作流，横轴代表时间。</li>
<li><img src="./imgs/image-20231224103617599.png" alt="image-20231224103617599"></li>
</ul>
</li>
<li>② 核心工作流
<ul>
<li>如上图纵轴所示，由上至下有九个核心工作流，前六个为核心过程工作流程，后三个为核心支持工作流程。</li>
</ul>
</li>
<li>③ 工作阶段
<ul>
<li>a. 初始阶段。</li>
<li>b．精化阶段。</li>
<li>c．构建阶段。</li>
<li>d．移交阶段。</li>
</ul>
</li>
<li>④ 特点
<ul>
<li>a. 采用迭代和渐增的方式开发软件。</li>
<li>b. 具有多功能性和广泛适用性。</li>
</ul>
</li>
</ul>
<h4 id="147-敏捷过程">1.4.7 敏捷过程</h4>
<ul>
<li>敏捷过程能够较好地适应商业竞争环境下对小型项目提出的有限资源和有限开发时间的约束。敏捷过程中最重要的是极限编程。</li>
</ul>
<h4 id="148-极限编程">1.4.8 极限编程</h4>
<ul>
<li>① 极限编程的整体开发过程
<ul>
<li>图描述了极限编程的整体开发过程。</li>
<li><img src="./imgs/image-20231224103623526.png" alt="image-20231224103623526"></li>
</ul>
</li>
<li>② 极限编程的迭代过程
<ul>
<li>图描述了极限编程的迭代开发过程。</li>
<li><img src="./imgs/image-20231224103628524.png" alt="image-20231224103628524"></li>
</ul>
</li>
<li>③ 特点
<ul>
<li>a. 以极限编程为代表的敏捷过程，具有对变化和不确定性的更快速、更敏捷的反应特性；</li>
<li>b. 在快速的同时仍然能够保持可持续的开发速度。</li>
</ul>
</li>
</ul>
<h4 id="149-微软过程">1.4.9 微软过程</h4>
<ul>
<li>
<p>① 微软软件生命周期</p>
<ul>
<li>微软过程把软件生命周期划分成五个阶段，图描绘了生命周期的阶段及每个阶段的主要里程碑。</li>
<li><img src="./imgs/image-20231224103634983.png" alt="image-20231224103634983"></li>
</ul>
</li>
<li>
<p>② 微软过程模型</p>
<ul>
<li>
<p>a. 定义</p>
<ul>
<li>微软过程的每一个生命周期发布一个递进的软件版本，各个生命周期持续、快速地迭代循环</li>
<li>图描绘了微软过程的生命周期模型。</li>
<li><img src="./imgs/image-20231224103642078.png" alt="image-20231224103642078"></li>
</ul>
</li>
<li>
<p>b. 特点</p>
<ul>
<li>第一，适用于商业环境下具有有限资源和有限开发时间约束的项目；</li>
<li>第二，微软过程也有某些不足之处，例如，对方法、工具和产品等方面的论述不如 RUP 和敏捷过程全面，人们对它的某些准则本身也有不同意见。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第二章-可行性分析">第二章 可行性分析</h2>
<h3 id="21-可行性研究的任务">2.1 可行性研究的任务</h3>
<ul>
<li>可行性研究的目的
<ul>
<li>用最小的代价在尽可能短的时间内确定问题是否能够解决。</li>
</ul>
</li>
<li>可行性研究的 3 个方面
<ul>
<li>（1）技术可行性；</li>
<li>（2）经济可行性；</li>
<li>（3）操作可行性。</li>
</ul>
</li>
<li>可行性研究的任务
<ul>
<li>（1）对以后的行动方针提出建议。（可行性研究最根本的任务）</li>
<li>（2）分析几种主要的候选解法的利弊，研究其可行性。</li>
</ul>
</li>
</ul>
<h3 id="22-可行性研究过程">2.2 可行性研究过程</h3>
<ul>
<li>典型的可行性研究过程为：
<ol>
<li>复查系统规模和目标；</li>
<li>研究目前正在使用的系统；</li>
<li>导出新系统的高层逻辑模型；</li>
<li>进一步定义问题；</li>
<li>导出并评价供选择的解法；</li>
<li>推荐行动方针；</li>
<li>草拟开发计划；</li>
<li>书写文档提交审查。</li>
</ol>
</li>
</ul>
<h3 id="23-系统流程图">2.3 系统流程图</h3>
<ul>
<li>
<p>定义</p>
<ul>
<li>系统流程图是概括地描绘物理系统的传统工具。系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程。因此尽管系统流程图的符号形式相同，但是它却是物理数据流程图而不是程序流程图。</li>
</ul>
</li>
<li>
<p>基本思想</p>
<ul>
<li>用图形符号以黑盒子形式描绘组成系统的每个部件（程序、文档、数据库、人工过程等）。</li>
<li>【注意】系统流程图表达的是数据在系统各部件之间流动的情况，而不是对数据进行加工处理的控制过程。</li>
</ul>
</li>
<li>
<p>符号</p>
<ul>
<li>
<p>（1）以概括的方式抽象地描绘实际系统时，使用图 2-1 中列出的基本符号就足够了。</p>
<ul>
<li>
<img src="./imgs/image-20231226111137168.png" alt="image-20231226111137168" style="zoom: 80%;" />
</li>
<li>【注意】这 5 种基本符号是常考点。</li>
</ul>
</li>
<li>
<p>（2）需要更具体地描绘一个物理系统时，还需要使用图 2-2 中列出的系统符号。</p>
<ul>
<li>
<img src="./imgs/image-20231226111214255.png" alt="image-20231226111214255" style="zoom:80%;" />
</li>
<li>
<p>【注意】系统流程图的习惯画法是使信息在图中从顶向下或从左向右流动。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><img src="./imgs/f77ebfd028cd407697cbf1dd305cbe0a.png" alt=""></p>
</li>
</ul>
<h3 id="24-数据流图概念">2.4 数据流图概念</h3>
<ul>
<li>
<p>（1）定义</p>
<ul>
<li>数据流图（DFD）是一种图形化技术。它描绘信息流和数据从输入移动到输出的过程中所经受的变换。</li>
</ul>
</li>
<li>
<p>（2）特点</p>
<ul>
<li>① 数据流图中没有具体的物理部件，只是描绘数据在软件中流动和被处理的逻辑过程。</li>
<li>② 数据流图是系统逻辑功能的图形表示，是分析员与用户之间极好的通信工具。</li>
<li>③ 设计时只需考虑系统必须完成的基本逻辑功能，不考虑怎样具体地实现这些功能。</li>
</ul>
</li>
<li>
<p>符号</p>
<ul>
<li>如图（a）所示，数据流图有 4 种基本符号；图（b）给出了附加符号的含义。其中星号（*）表示数据流之间是 “与” 关系；加号（＋）表示 “或” 关系；⊕ 号表示只能从中选一个（互斥的关系）。</li>
<li><img src="./imgs/b4b758719d2a4e9e816f25edc3a6d332.png" alt=""></li>
<li>数据流图有 4 种成分，源点或终点、处理、数据存储、数据流</li>
<li>【注意】数据流中用箭头表示数据流，第 5 章的程序流程图中用箭头表示的控制流。</li>
</ul>
</li>
<li>
<p>数据存储和数据流都是数据，数据存储是处于静止状态的数据，数据流是处理运动中的数据</p>
</li>
<li>
<p>例子</p>
<ul>
<li>
<p><img src="./imgs/222546b8e8974832828d39153ba65373.png" alt=""></p>
</li>
<li>
<p><img src="./imgs/2a8cbb2569ef418fb9de1fd042bda525.png" alt=""></p>
</li>
<li>
<p><img src="./imgs/3461ee48c568436687a16b1a4cdad60d.png" alt=""></p>
</li>
<li>
<p><img src="./imgs/b8ff75647c9a4307b81ce684c6720f80.png" alt=""></p>
</li>
</ul>
</li>
<li>
<p>数据流图的基本目的，利用数据流图作为交流信息的工具</p>
</li>
<li>
<p>数据流图也可用于作为分析和设计的工具</p>
</li>
</ul>
<h3 id="25-数据字典">2.5 数据字典</h3>
<ul>
<li>概念
<ul>
<li>（1）定义
<ul>
<li>数据字典是关于数据的信息的集合，是对数据流图中包含的所有元素的定义的集合。</li>
</ul>
</li>
<li>（2）数据字典的作用
<ul>
<li>在软件分析和设计的过程中给人提供关于数据的描述信息</li>
</ul>
</li>
<li>（3）意义
<ul>
<li>数据流图和数据字典共同构成系统的逻辑模型。</li>
</ul>
</li>
</ul>
</li>
<li>数据字典的组成元素
<ul>
<li>① 数据流；</li>
<li>② 数据流分量，即数据元素；</li>
<li>③ 数据存储；</li>
<li>④ 处理。</li>
</ul>
</li>
<li>定义数据的方法
<ul>
<li>由数据元素组成的数据的方式 3 种基本类型：
<ul>
<li>顺序（3 种基本类型）</li>
<li>选择（3 种基本类型）</li>
<li>重复（3 种基本类型）</li>
<li>可选</li>
</ul>
</li>
<li>描述由数据元素组成数据的关系
<ul>
<li>① = 等价于（定义为）</li>
<li>② + 和（连接两个分量）</li>
<li>③ [] 或（从方括号中的分量选择一个），通常用 “|” 号隔开供选择的分量</li>
<li>④ {} 重复（重复花括号中的分量），字母数字串 = 0{字母或数字}7，允许字母或数字的长度为 0-7</li>
<li>⑤ ( ) 选择（括号中的分量可有可无）</li>
</ul>
</li>
</ul>
</li>
<li>数据字典的用途
<ul>
<li>（1）作为分析阶段的工具（最重要）。</li>
<li>（2）数据字典中包含的每个数据元素的控制信息是很有价值的。</li>
<li>（3）数据字典是开发数据库的第一步，而且是很有价值的一步。</li>
</ul>
</li>
<li>数据字典的实现
<ul>
<li>（1）开发大型软件系统时建议使用数据字典处理程序。</li>
<li>（2）在开发小型软件系统时建议采用卡片形式书写数据字典，如图
<ul>
<li><img src="./imgs/e32a13d424cd4e999788189ccd6d9564.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="26-成本--效益分析">2.6 成本 / 效益分析</h3>
<ul>
<li>
<p>目的</p>
<ul>
<li>帮助客户组织负责人从经济角度判断是否继续投资于这项工程。</li>
</ul>
</li>
<li>
<p>成本估计的方法</p>
<ul>
<li>（1）代码行技术；
<ul>
<li>每行代码的平均成本乘以行数</li>
<li>每行代码的平均成本取决于软件的复杂程度和工资水平</li>
</ul>
</li>
<li>（2）任务分解技术；
<ul>
<li>总成本 = 每个任务成本之和</li>
<li>每个任务的成本 = 人力 (以人月为单位) X 每人每月平均工资</li>
</ul>
</li>
<li>（3）自动估计成本技术。
<ul>
<li>采用自动估计成本的软件工具</li>
</ul>
</li>
</ul>
</li>
<li>
<p>成本效益分析</p>
<ul>
<li>
<blockquote>
<p>成本与收益比较要相同时间的进行比较，现在与现在比较。</p>
</blockquote>
</li>
<li>
<p>计算 P 元钱在 n 年后的价值： F = P ( 1 + i ) n F=P(1+i)^n F=P(1+i)n，其中年利率为 i。</p>
</li>
<li>
<p>n 年后能收入 F 元钱，计算这些钱的现在价值： P = F / ( 1 + i ) n P=F/(1+i)^n P=F/(1+i)n。</p>
<ul>
<li><img src="./imgs/dd06a64bed8c499d9da3b3488802e277.png" alt=""></li>
</ul>
</li>
<li>
<p>投资回收期：使累计的经济效益等于最初投资所需的时间</p>
<ul>
<li><img src="./imgs/bccaca5230314f9093486d71e8b4ef24.png" alt=""></li>
</ul>
</li>
<li>
<p>纯收入</p>
<ul>
<li><img src="./imgs/ab5c2ac9ee824fe2bb1870872448a125.png" alt=""></li>
</ul>
</li>
<li>
<p>计算投资回收率： P = F 1 / ( 1 + j ) + F 2 / ( 1 + j ) 2 + … + F n / ( 1 + j ) n P=F1/(1+j)+F2/(1+j)^2+…+Fn/(1+j)^n P=F1/(1+j)+F2/(1+j)2+…+Fn/(1+j)n</p>
<ul>
<li>其中，P 是现在的投资额；Fi 是第 i 年年底的效益（i ＝ 1，2，…，n）；n 是系统的使用寿命；j 是投资回收率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第三章-需求分析">第三章 需求分析</h2>
<ul>
<li>需求分析是软件定义时期的最后一个阶段，需求分析的基本任务是准确的回答 “系统必须做什么” 这个问题</li>
<li>需求分析阶段系统分析员需要写出软件需求规格说明书</li>
<li>在需求分析阶段通常建立数据模型（实体 - 联系图（ E-R 图））、功能模型（数据流图）、行为模型（状态转换图是行为模型的基础），数据字典成为把 3 种分析模型粘合在一起的 “粘合剂”，是分析模型的核心。</li>
</ul>
<h3 id="31-需求分析的任务">3.1 需求分析的任务</h3>
<ul>
<li>需求分析的定义
<ul>
<li>需求分析是发现、求精、建模、规格说明和复审的过程。</li>
</ul>
</li>
<li>需求分析的必要性
<ul>
<li>为了开发出真正满足用户需求的成功的软件产品，必须知道用户的需求。</li>
</ul>
</li>
<li>需求分析的任务
<ul>
<li>（1）确定对系统的综合要求；
<ul>
<li>（1）功能需求</li>
<li>（2）性能需求</li>
<li>（3）可靠性和可用性需求</li>
<li>（4）出错处理需求</li>
<li>（5）接口需求</li>
<li>（6）约束</li>
<li>（7）逆向需求</li>
<li>（8）将来可能提出的要求</li>
</ul>
</li>
<li>（2）分析系统的数据要求；
<ul>
<li>数据结构表示数据元素之间的逻辑关系</li>
<li>利用数据字典可以全面准确的定义数据（不够形象直观）</li>
<li>在描绘系统中的数据结构，使用层次方框图或 Warnier 图等图形工具。（提高可理解性）</li>
</ul>
</li>
<li>（3）导出系统的逻辑模型；
<ul>
<li>通常使用数据流图、实体 - 联系图、状态转换图、数据字典、主要的处理算法描述逻辑模型</li>
</ul>
</li>
<li>（4）修正系统开发计划。</li>
</ul>
</li>
</ul>
<h3 id="32-与用户沟通获取需求的方法">3.2 与用户沟通获取需求的方法</h3>
<ul>
<li>访谈
<ul>
<li>正式访谈，系统分析员提出事先准备好的具体问题</li>
<li>非正式访谈，分析员提出用户可以自由回答的开放性问题</li>
</ul>
</li>
<li>面向数据流自顶向下求精
<ul>
<li>先建立一个初步的系统功能模型，然后按照基本思想，自顶向下，逐步对顶层数据流图进行细分</li>
<li>结构化分析方法就是面向数据流自顶向下逐步求精进行需求分析的方法</li>
</ul>
</li>
<li>简易的应用规格说明技术
<ul>
<li>进行初步访谈；</li>
<li>开发者和用户分别写出 “产品需求”；</li>
<li>选定会议的时间和地点，选举协调人；</li>
<li>邀请开发者和用户双方组织的代表出席会议；</li>
<li>列出系统环境组成部分的对象、系统将产生的对象、系统为完成自己的功能将使用的对象，列出操作这些对象或与这些对象交互的服务，列出约束条件和性能标准；</li>
<li>共同起草完整的软件需求规格说明书</li>
</ul>
</li>
<li>快速建立软件原型
<ul>
<li>首先通过初步需求，快速建立一个系统原型；然后运行给用户看，用户根据原型提出自己的修改意见，最后程序开发者根据用户的建议，对原型进行修改和完善。如此反复的迭代进行，知道最终建立一个满足用户需求的软件系统为止</li>
<li>特性：快速、容易修改</li>
<li>快速构建和修改原型的方法和工具
<ul>
<li>第四代技术</li>
<li>可重用的软件构件</li>
<li>形式化规格说明和原型环境</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="33-分析建模与规格说明">3.3 分析建模与规格说明</h3>
<ul>
<li>分析建模
<ul>
<li>（1）模型
<ul>
<li>模型由一组图形符号和组织这些符号的规则组成。</li>
<li>为了理解事物而对事物作出的抽象</li>
<li>对事物的一种无歧义的书面描述</li>
</ul>
</li>
<li>（2）建模过程
<ul>
<li>结构化分析实质上是一种创建模型的活动，应从不同的角度抽象目标系统的特性。</li>
</ul>
</li>
<li>实体 - 联系图：描绘数据对象和数据对象之间的关系，用于建立数据模型的图形</li>
<li>数据流图：描绘当数据在软件系统中移动时被交换的逻辑过程，指明系统具有的变换数据的功能，数据流图是建立功能模型的基础</li>
<li>状态转换图：描绘了系统的各种行为模式（称为状态）和在不同状态间转换的方式，状态转换图是行为建模的基础</li>
</ul>
</li>
<li>软件需求规格说明
<ul>
<li>软件需求规格说明书是需求分析阶段得出的最主要的文档。</li>
</ul>
</li>
</ul>
<h3 id="34-实体---联系图e-r-图">3.4 实体 - 联系图（E-R 图）</h3>
<ul>
<li>数据模型的定义
<ul>
<li>概念性数据模型（信息模型）是一种面向问题的数据模型，是按照用户的观点对数据建立的模型。</li>
</ul>
</li>
<li>数据模型的构成</li>
<li>（1）数据对象
<ul>
<li>① 定义
<ul>
<li>数据对象是对软件必须理解的复合信息的抽象。</li>
</ul>
</li>
<li>② 特点
<ul>
<li>a. 可以由一组属性来定义的实体都可以被认为是数据对象。</li>
<li>b. 数据对象彼此间是有关联的。</li>
<li>c. 数据对象只封装了数据而没有对施加于数据上的操作的引用。</li>
</ul>
</li>
</ul>
</li>
<li>（2）数据对象的属性（属性）
<ul>
<li>属性定义了数据对象的性质。</li>
</ul>
</li>
<li>（3）数据对象彼此间相互连接的关系（联系）
<ul>
<li>数据对象彼此之间相互连接的方式称为联系，也称为关系。</li>
<li>联系也可能有属性。</li>
<li>联系可分为以下 3 种类型
<ul>
<li>① 一对一联系（1：1）</li>
<li>② 一对多联系（1：N）</li>
<li>③ 多对多联系（M：N）</li>
</ul>
</li>
</ul>
</li>
<li>实体 - 联系图（E-R 图）
<ul>
<li>实体 - 联系图用于建立数据模型</li>
<li>ER 图描绘的数据模型称为 ER 模型</li>
<li>ER 图的基本成分
<ul>
<li>E-R 图中包含了实体（数据对象）、关系和属性 3 种基本成分</li>
<li>通常用矩形框代表实体</li>
<li>用连接相关实体的菱形框表示关系</li>
<li>用椭圆形或圆角矩形表示实体（或关系）的属性，并用直线把实体（或关系）与其属性连接起来。</li>
</ul>
</li>
<li>优点
<ul>
<li>① E-R 模型比较接近人的习惯思维方式；</li>
<li>② E-R 模型使用简单的图形符号来描述问题，便于用户理解。</li>
</ul>
</li>
<li>ER 模型可以作为用户与分析员之间的交流工具</li>
<li>
<img src="./imgs/image-20231227222231382.png" alt="image-20231227222231382" style="zoom:80%;" />
</li>
</ul>
</li>
</ul>
<h3 id="35-数据规范化">3.5 数据规范化</h3>
<ul>
<li>数据规范化减少数据冗余，避免出现插入异常或删除异常，简化修改数据的过程</li>
<li>使用范式消除数据冗余的程度</li>
</ul>
<h3 id="36-状态转换图">3.6 状态转换图</h3>
<ul>
<li>定义
<ul>
<li>状态转换图（状态图）通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。</li>
</ul>
</li>
<li>状态
<ul>
<li>（1）定义
<ul>
<li>状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。</li>
</ul>
</li>
<li>（2）分类
<ul>
<li>状态主要有：初态（初始状态）、终态（最终状态）和中间状态。</li>
<li>【注意】在一张状态图中只能有一个初态，而终态则可以有 0 至多个。描绘单程生命周期时需要标明初始状态和最终状态</li>
</ul>
</li>
</ul>
</li>
<li>事件
<ul>
<li>事件是在某个特定时刻发生的事情，是对引起系统做动作或从一个状态转换到另一个状态的外界事件的抽象，是引起系统做动作或（和）转换状态的控制信息。</li>
</ul>
</li>
<li>状态图的符号
<ul>
<li>（1）符号的表示方法
<ul>
<li>① 初态：用实心圆表示。</li>
<li>② 终态：用一对同心圆（内圆为实心圆）表示。</li>
<li>③ 中间状态：用圆角矩形表示。可以用两条水平横线把它分成上、中、下 3 个部分。上面部分为状态的名称，这部分是必须有的；中间部分为状态变量的名字和值，下面部分是活动表。</li>
</ul>
</li>
<li>（2）组成部分
<ul>
<li>图给出了状态图中使用的主要组成部分和符号表示。
<ul>
<li>
<img src="./imgs/image-20231227222252980.png" alt="image-20231227222252980" style="zoom:80%;" />
</li>
</ul>
</li>
<li>① 活动表
<ul>
<li>活动表的语法格式为：事件名（参数表）/ 动作表达式</li>
<li>在活动表中经常使用下述 3 种标准事件：entry，exit 和 do。entry 事件指定进入该状态的动作；exit 事件指定退出该状态的动作；do 事件则指定在该状态下的动作。</li>
</ul>
</li>
<li>② 状态转换
<ul>
<li>状态图中两个状态之间带箭头的连线称为状态转换，箭头指明了转换方向。</li>
<li>状态如果由事件触发，需要在状态转换的箭头上标出触发转换的事件表达式，如果不是由事件触发 (执行完内部活动后自动触发) 则不用标明。</li>
</ul>
</li>
<li>③ 事件表达式
<ul>
<li>事件表达式的语法为：事件说明 [守卫条件]/ 动作表达式，其中，事件说明的语法为：事件名（参数表）。</li>
<li>守卫条件是一个布尔表达式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>例子
<ul>
<li>
<img src="./imgs/image-20231227222319321.png" alt="image-20231227222319321" style="zoom:80%;" />
</li>
</ul>
</li>
</ul>
<h3 id="37-其他图形工具">3.7 其他图形工具</h3>
<ul>
<li>
<p>层次方框图</p>
<ul>
<li>层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。</li>
<li>
<img src="./imgs/image-20231227222339792.png" alt="image-20231227222339792" style="zoom:80%;" />
</li>
</ul>
</li>
<li>
<p>Warnier 图</p>
<ul>
<li>Warnier 图有以下三种基本符号：
<ul>
<li>① 花括号：用来区分数据结构的层次，在一个花括号内的所有名字都属于同一类信息。</li>
<li>② 异或符号：表明一类信息或一个数据元素在一定条件下才出现。</li>
<li>③ 圆括号中的数字：指明了这个名字代表的信息类在这个数据结构中重复出现的次数。</li>
</ul>
</li>
<li>
<img src="./imgs/image-20231227222356833.png" alt="image-20231227222356833" style="zoom:80%;" />
</li>
</ul>
</li>
<li>
<p><a href="https://so.csdn.net/so/search?q=IPO%E5%9B%BE&amp;spm=1001.2101.3001.7020">IPO 图</a></p>
</li>
<li>
<p>（1）定义</p>
<ul>
<li>IPO 图是输入、处理、输出图的简称，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。</li>
</ul>
</li>
<li>
<p>（2）基本形式和用法</p>
<ul>
<li>① 左边的框中列出有关的输入数据；</li>
<li>② 中间的框内列出主要的处理；</li>
<li>③ 右边的框内列出产生的输出数据；</li>
<li>④ 粗大箭头指出数据通信的情况。</li>
<li>处理框中列出处理的次序暗示了执行的顺序。</li>
<li>
<img src="./imgs/image-20231227222422462.png" alt="image-20231227222422462" style="zoom:80%;" />
</li>
</ul>
</li>
<li>
<p>（3）改进的 IPO 图</p>
<ul>
<li>改进的 IPO 图（IPO 表）中包含某些附加的信息。如图 3-2 所示，改进的<br>
IPO 图中包含的附加信息主要有系统名称、图的作者，完成的日期，本图描述的模块的名字，模块在层次图中的编号，调用本模块的模块清 单，本模块调用的模块的清单，注释，以及本模块使用的局部数据元素等。</li>
<li>
<img src="./imgs/image-20231227222450824.png" alt="image-20231227222450824" style="zoom:80%;" />
</li>
</ul>
</li>
<li>
<p>【注意】要区分并牢记给定图形工具可用于<a href="https://so.csdn.net/so/search?q=%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&amp;spm=1001.2101.3001.7020">软件生命周期</a>的哪一阶段，此为常考题。本节三种图形工具均可用于需求分析阶段。</p>
</li>
</ul>
<h3 id="38-验证软件需求">3.8 验证软件需求</h3>
<ul>
<li>验证软件需求的正确性
<ul>
<li>（1）验证需求正确性的目的
<ul>
<li>为了提高软件质量，确保软件开发成功，降低软件开发成本。</li>
</ul>
</li>
<li>（2）进行验证的四个方面
<ul>
<li>① 一致性，需求之间不能相互矛盾；</li>
<li>② 完整性，要实现每一个需求；</li>
<li>③ 现实性，指定的需求是在现有的硬件技术和软件技术的基础上可以实现；</li>
<li>④ 有效性，需求可以解决用户面对的问题。</li>
</ul>
</li>
</ul>
</li>
<li>验证软件需求的方法
<ul>
<li>（1）验证需求的一致性；</li>
<li>（2）验证需求的现实性；</li>
<li>（3）验证需求的完整性和有效性。</li>
</ul>
</li>
<li>用于需求分析的软件工具——PSL/PSA 系统
<ul>
<li>① 定义
<ul>
<li>PSL 是用来描述系统的形式语言，PSA 是处理 PSL 描述的分析程序。</li>
</ul>
</li>
<li>② 功能
<ul>
<li>a. 描述任何应用领域的信息系统；</li>
<li>b. 创建一个数据库保存对该信息系统的描述符；</li>
<li>c. 对描述符施加增加、删除和更改等操作；</li>
<li>d. 产生格式化的文档和关于规格说明书的各种分析报告。</li>
</ul>
</li>
<li>③ 优点
<ul>
<li>a. 改进了文档质量，能保证文档具有完整性、一致性和无二义性，从而可以 - 减少管理和维护的费用；</li>
<li>b. 数据存放在数据库中，便于增加、删除和更改。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第五章-总体设计">第五章 总体设计</h2>
<ul>
<li>目的
<ul>
<li>总体设计的基本目的就是回答 “概括地说，系统应该如何实现” 这个问题。</li>
</ul>
</li>
<li>总体设计又称为概要设计或初步设计</li>
<li>主要任务
<ul>
<li>（1）划分出组成系统的物理元素——程序、文件、数据库、人工过程和文档等。</li>
<li>（2）确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系。</li>
<li>【注意】每个物理元素的具体实现是详细阶段的任务。</li>
</ul>
</li>
<li>必要性
<ul>
<li>可以站在全局高度上，以较少的成本选出最佳方案和最合理的软件结构并开发出较高质量的软件系统。</li>
</ul>
</li>
</ul>
<h3 id="51-设计过程">5.1 设计过程</h3>
<ul>
<li>设计过程的两个主要组成阶段
<ul>
<li>（1）系统设计阶段，确定系统的具体实现方案。</li>
<li>（2）结构设计阶段，确定软件结构。</li>
</ul>
</li>
<li>典型的总体设计过程
<ul>
<li>①设想供选择的方案；</li>
<li>②选取合理的方案</li>
<li>③推荐最佳方案</li>
<li>④功能分解</li>
<li>⑤设计软件结构</li>
<li>⑥设计数据库</li>
<li>⑦制定测试计划</li>
<li>⑧书写文档
<ul>
<li>系统说明</li>
<li>用户手册</li>
<li>测试计划</li>
<li>详细的实现计划</li>
<li>数据库设计结果</li>
</ul>
</li>
<li>⑨审查和复查。</li>
</ul>
</li>
</ul>
<h3 id="52-设计原理">5.2 设计原理</h3>
<h4 id="521-模块化">5.2.1 模块化</h4>
<ul>
<li>（1）定义
<ul>
<li>模块化就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。</li>
</ul>
</li>
<li>（2）优点
<ul>
<li>① 使软件结构清晰，不仅容易设计也容易阅读和理解。</li>
<li>② 使软件容易测试和调试，有助于提高软件的可靠性。</li>
<li>③ 提高软件的可修改性。</li>
<li>④ 有助于软件开发工程的组织管理。</li>
</ul>
</li>
<li>【注意】模块是构成程序的基本构件。</li>
</ul>
<h4 id="522-抽象">5.2.2 抽象</h4>
<ul>
<li>（1）定义
<ul>
<li>抽象就是抽出事物的本质特性而暂时不考虑它们的细节。</li>
</ul>
</li>
<li>（2）优点
<ul>
<li>① 简化了软件的设计和实现；</li>
<li>② 提高了软件的可理解性和可测试性；</li>
<li>③ 使得软件更容易维护。</li>
</ul>
</li>
<li>软件工程过程的每一步都是对软件解法的抽象层次的一次精化</li>
</ul>
<h4 id="523-逐步求精">5.2.3 逐步求精</h4>
<ul>
<li>（1）定义
<ul>
<li>定义为：为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。</li>
</ul>
</li>
<li>（2）原理
<ul>
<li>① 逐步求精是一种自顶向下的设计策略。</li>
<li>② 求精实际上是细化过程。</li>
</ul>
</li>
<li>逐步求精如此重要？
<ul>
<li>因为人类的认知过程遵循 Miller 法则，一个人在任何时候都只能把注意力集中在（7+2）个知识块上</li>
</ul>
</li>
<li>抽象与求精是一对互补概念</li>
</ul>
<h4 id="524-信息隐藏和局部化">5.2.4 信息隐藏和局部化</h4>
<ul>
<li>（1）局部化定义
<ul>
<li>指把一些关系密切的软件元素物理地放得彼此靠近。</li>
</ul>
</li>
<li>（2）信息隐藏原理
<ul>
<li>使得一个模块内包含的信息（主要是实现细节）对于不需要这些信息的模块来说，是不能访问的。</li>
</ul>
</li>
<li>局部化有助于信息隐藏</li>
</ul>
<h4 id="525-模块独立">5.2.5 模块独立</h4>
<ul>
<li>（1）定义
<ul>
<li>开发的模块具有独立功能而且和其他模块之间没有过多的相互作用的模块，就可以做到模块独立。</li>
<li>模块独立的概念是模块化、抽象、信息隐藏和局部化的直接结果。</li>
</ul>
</li>
<li>（2）模块的独立程度由两个定性标准衡量：耦合和内聚。</li>
<li>（3）耦合
<ul>
<li>① 定义
<ul>
<li>耦合是对一个软件结构内不同模块之间互连程度的度量。</li>
</ul>
</li>
<li>② 分类
<ul>
<li>a. 完全独立，模块间没有任何连接；</li>
<li>b. 数据耦合，模块之间仅通过交换数据来交换信息；</li>
<li>c．控制耦合，模块之间传递的信息有控制信息；</li>
<li>d．特征耦合，传递的数据为整个数据结构，但只使用其中的一部分数据元素；</li>
<li>e. 公共环境耦合，模块之间通过公共数据环境相互作用；</li>
<li>f. 内容耦合
<ul>
<li>模块访问模块内部数据</li>
<li>模块进入另一个模块没有通过正常入口</li>
<li>模块之间部分程序代码重叠</li>
<li>一个模块有多个入口</li>
</ul>
</li>
<li>数据耦合 &lt; 公共环境耦合 &lt; 特征耦合 &lt; 控制耦合 &lt; 内容耦合（越低越好）</li>
</ul>
</li>
</ul>
</li>
<li>（4）内聚
<ul>
<li>① 定义
<ul>
<li>内聚衡量一个模块内部各个元素彼此结合的紧密程度。</li>
</ul>
</li>
<li>② 分类
<ul>
<li>偶然内聚，模块内任务的关系松散</li>
<li>逻辑内聚，模块完成的任务逻辑上属于相同或类似的一类</li>
<li>时间内聚，模块的任务必须在同一时间段执行</li>
<li>过程内聚，模块内处理元素相关且按一定的次序</li>
<li>通信内聚，模块中所有元素使用同一个输入或产生同一个的输出</li>
<li>顺序内聚，模块中的功能必须顺序执行</li>
<li>功能内聚，模块中所有处理元素属于一个整体，完成一个单一的功能</li>
<li>低内聚（偶然内聚 &lt; 逻辑内聚 &lt; 时间内聚）</li>
<li>中内聚（过程内聚 &lt; 通信内聚）</li>
<li>高内聚（顺序内聚 &lt; 功能内聚）</li>
</ul>
</li>
</ul>
</li>
<li>【注意】：设计的软件尽量满足 “高内聚、低耦合” 和“高扇入、低扇出”原则。</li>
<li>模块独立性比较强的模块应该是具有高内聚性和低耦合度。</li>
<li>在进行软件结构设计时应该遵循的最主要的原理是模块独立原理；</li>
<li>自顶向下逐步求精是进行软件结构设计的常用途径；</li>
<li>抽象和逐步求精是互补的。</li>
</ul>
<h3 id="53-启发规则">5.3 启发规则</h3>
<ul>
<li>改进软件结构提高模块独立性</li>
<li>模块规模应该适中</li>
<li>深度、宽度、扇出和扇入都应适当
<ul>
<li>（1）深度
<ul>
<li>深度表示软件结构中控制的层数。</li>
</ul>
</li>
<li>（2）宽度
<ul>
<li>宽度是软件结构内同一个层次上的模块总数的最大值。宽度越大系统越复杂。对宽度影响最大的因素是模块的扇出。</li>
</ul>
</li>
<li>（3）扇出
<ul>
<li>扇出是一个模块直接控制的模块数目。</li>
</ul>
</li>
<li>（4）扇入
<ul>
<li>扇入表明有多少个上级模块直接调用它。</li>
</ul>
</li>
</ul>
</li>
<li>模块的作用域应该在控制域之内
<ul>
<li>（1）定义
<ul>
<li>① 模块的作用域定义为受该模块内一个判定影响的所有模块的集合。</li>
<li>② 模块的控制域是这个模块本身以及所有直接或间接从属于它的模块的集合。</li>
</ul>
</li>
</ul>
</li>
<li>力争降低模块接口的复杂程度</li>
<li>设计单入口单出口的模块</li>
<li>模块功能应该可以预测</li>
</ul>
<h3 id="54-描绘软件结构的图形工具">5.4 描绘软件结构的图形工具</h3>
<h4 id="541-层次图">5.4.1 层次图</h4>
<ul>
<li>（1）作用
<ul>
<li>层次图用来描绘软件的层次结构。</li>
</ul>
</li>
<li>（2）符号
<ul>
<li>① 矩形框代表一个模块。</li>
<li>② 方框间的连线表示调用关系。</li>
</ul>
</li>
<li>
<img src="./imgs/image-20231230172405503.png" alt="image-20231230172405503" style="zoom:80%;" />
</li>
</ul>
<h4 id="542-hipo-图">5.4.2 HIPO 图</h4>
<ul>
<li>HIPO 图是 “层次图加输入 / 处理 / 输出图” 的缩写。</li>
<li>在层次图里除了最顶层的方框外，每个方框都加了编号。</li>
<li><img src="./imgs/2622dbc31241489992b6b63671d515af.png" alt=""></li>
</ul>
<h4 id="543-结构图">5.4.3 结构图</h4>
<ul>
<li>结构图的符号表示分为两类：</li>
<li>（1）基本符号
<ul>
<li>① 方框代表一个模块，框内注明模块的名字或主要功能；</li>
<li>② 方框之间的箭头（或直线）表示模块的调用关系；</li>
<li>③ 尾部是空心圆的箭头表示传递的是数据，实心圆的箭头表示传递的是控制信息。</li>
<li><img src="./imgs/767af720660e405dbf2eb975ce64f3cf.png" alt=""></li>
</ul>
</li>
<li>（2）特殊符号
<ul>
<li>① 表示当模块 M 中某个判定为真时调用模块 A，为假时调用模块 B，如图所示；</li>
<li><img src="./imgs/c0610753203a40bbaa7a1b12595d255e.png" alt=""></li>
<li>② 表示模块 M 循环调用模块 A、B 和 C，如图所示。</li>
<li><img src="./imgs/f7e20b85183144f787baddce34d24960.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="55-面向数据流的设计方法">5.5 面向数据流的设计方法</h3>
<ul>
<li>面向数据流的设计方法的目标：给出设计软件结构的一个系统化的途径</li>
<li>通常使用数据流图描绘信息在系统中加工和流动的情况</li>
<li>结构化设计方法是基于数据流的设计方法</li>
<li>信息流的类型
<ul>
<li>（1）变换流
<ul>
<li>变换流具有如下特征：
<ul>
<li>① 信息沿输入通路进入系统，同时由外部形式变换成内部形式；</li>
<li>② 进入系统的信息通过变换中心，经加工处理后沿输出通路变成外部形式离开软件系。</li>
</ul>
</li>
<li><img src="./imgs/81331319a59542d587bd175ed4f79bba.png" alt=""></li>
</ul>
</li>
<li>（2）事务流
<ul>
<li>事务流是 “以事务为中心” 的数据流，即数据沿输入通路到达一个处理 T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。</li>
<li>事务流完成接收输入数据、分析每个事务确定事务类型、根据事务选择活动通路的任务</li>
<li><img src="./imgs/0b08cabdbd744942afe7d7f073b3c7bb.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>设计过程
<ul>
<li>下图说明了使用面向数据流方法逐步设计的过程。</li>
<li><img src="./imgs/614912dcd7694fc6a80c7eabece2789d.png" alt=""></li>
<li>【注意】任何设计过程都不是机械的一成不变的。</li>
</ul>
</li>
<li>变换分析
<ul>
<li>变换分析是一系列设计步骤的总称，经过这些步骤把具有变换流特点的数据流图按预先确定的模式映射成软件结构</li>
<li>（1）适用性
<ul>
<li>一般说来，如果数据流不具有显著的事务特点，最好使用变换分析。</li>
</ul>
</li>
<li>（2）设计步骤
<ul>
<li>① 复查基本系统模型；</li>
<li>② 复查并精化数据流图；</li>
<li>③ 确定数据流图具有变换特性还是事务特性；</li>
<li>④ 确定输入流和输出流的边界，从而孤立出变换中心；</li>
<li>⑤ 第一级分解；</li>
<li>⑥ 第二级分解；</li>
<li>⑦ 使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化。</li>
</ul>
</li>
</ul>
</li>
<li>事务分析
<ul>
<li>（1）适用性
<ul>
<li>在数据流具有明显的事务特点时，即有一个明显的事务中心时，采用事务分析方法为宜。</li>
</ul>
</li>
<li>（2）设计
<ul>
<li>事务分析的映射方法如图所示。</li>
<li><img src="./imgs/e05bc9a9babf45358b41348cfac561ac.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>设计优化
<ul>
<li>（1）设计优化时应遵循的原则。
<ul>
<li>① 应该开发能够满足所有功能和性能要求，而且按照设计原理和启发式设计规则衡量是值得接收的软件。</li>
<li>② 应该在设计的早期阶段尽量对软件结构进行精化。</li>
<li>③ 结构简单通常既表示设计风格优雅，又表明效率高。</li>
<li>④ 对于时间是决定性因素的应用场合，可能需要在详细设计阶段或在编写程序的过程中进行优化。</li>
</ul>
</li>
<li>（2）可以采用以下几种方法对时间起决定性作用的软件进行优化。
<ul>
<li>① 在不考虑时间因素的前提下开发并精化软件结构。</li>
<li>② 在详细设计阶段选出最耗费时间的那些模块，仔细地设计它们的处理过程（算法），以求提高效率。</li>
<li>③ 使用高级程序设计语言编写程序。</li>
<li>④ 在软件中孤立出那些大量占用处理机资源的模块。</li>
<li>⑤ 必要时重新设计或用依赖于机器的语言重写上述大量占用资源的模块的代码，以求提高效率。</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    
    

    

</div>

        </div>
        <div id="footer"><div class="container-footer">
    
    

    <div class="beian">
        
        <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=">
            

        </a>

        <a href="//tryanel.github.io/days/" target="_blank">
            
            明天，我们会更好
            
        </a>
    </div>

    <div class="info">
        <a href="https://github.com/Tryanel/Tryanel.github.io">Copyright</a> © 2023 - <span id="info-date"></span>
    </div>

</div></div>
        <div class="cool-after" style="background-color: rgba(255, 255, 255, 0.81);"></div>
    </body>
</html>
